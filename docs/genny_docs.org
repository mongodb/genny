* Introduction
Hello! These are the docs for Genny specifically. For an overall view of MongoDB's performance testing infrastructure, please look at the [[https://github.com/10gen/performance-tooling-docs][Performance Tooling Docs]].

If you have any questions, please reach out to the TIPS team in our dedicated slack channel: #performance-tooling-users. If you feel like these docs can be improved in any way, feel free to open a PR and assign someone from TIPS. No ticket necessary. This document is intended to be readable straight-through, in addition to serving as a reference on an as-needed basis. If there are any difficulties in flow or discoverability, please let us know.

* Getting Started and Building
For build instructions, see the installation guide [[file:setup.md][here]].

To try launching Genny, navigate to the root of the Genny repo and run the following: 

#+BEGIN_SRC
./run-genny workload src/workloads/docs/HelloWorld.yml
#+END_SRC

Whenever you have questions about the Genny CLI, you can always use the ~-h~ option for the top-level Genny CLI or any subcommands:

#+BEGIN_SRC
./run-genny -h # See all subcommands
./run-genny workload -h # See args and options for the workload subcommand
#+END_SRC

* Core Concepts
This section introduces the core concepts used by Genny, the minimal required syntax for its inputs, and builds up a basic example.
** What is load generation?
Genny is a *load generation* tool. It is used as a client in [[https://en.wikipedia.org/wiki/Load_testing][load tests]] to perform a large amount of work against a system under test, measuring the client-side visible responses of said test subject. These measurements may represent things like latency, number of operations performed, how many errors occurred, etc. The procedure Genny uses to perform the work should be as deterministic and repeatable as possible. This procedure is called a *workload*.

Results of a load test can inform developers as to the performance of the test subject in stressful situations. How does a system handle increasing numbers of connections performing conflicting operations? How does a system handle a large number of users performing one operation, then simultaneously switching to another in an instant? How does one user initiating a long-running, expensive operation affect the latencies observed by other users? All these situations can be simulated with Genny.
** What is the system under test?
Genny usually expects to be given a connection string to a system under test. While there's nothing preventing a user from writing a "workload" that spawns the system under test, there is not first-class support for such behavior. Genny is explicitly _not_ a test orchestrator. For test orchestration needs, consider using [[https://github.com/10gen/dsi/][DSI]].

By default, Genny will try to connect to a MongoDB server at ~localhost:27017~. To pass a MongoDB connection string to Genny, use the ~-u~ option:

#+BEGIN_SRC
./run-genny workload -u [arbitrary_URI] src/workloads/docs/InsertWithNop.yml
#+END_SRC

For more details on how Genny handles connections, see [[*Connecting to the Server][Connecting to the Server]].
** What is a workload?
A *workload* is a repeatable procedure that Genny uses to generate load against a system under test. Genny workloads are written in yaml configs that describe how *actors* move through *phases*. This section describes each of these.
*** How are workloads configured?
Here is an example of a simple Genny workload config:

#+BEGIN_SRC
SchemaVersion: 2018-07-01
Owner: "@10gen/dev-prod-tips"
Description: |
  This is an introductory workload that shows how to write a workload in Genny.
  This workload writes a few messages to the screen.

Keywords:
- docs
- HelloWorld

Actors:
- Name: HelloWorldExample
  Type: HelloWorld
  Threads: 2
  Phases:
  - Message: Hello Phase 0 üê≥
    Duration: 50 milliseconds
  - Message: Hello Phase 1 üë¨
    Repeat: 100
#+END_SRC

Everything under the ~Actor~ key (where the magic happens) will be explained in the next section. First let's look at the other *required* keys:

- ~SchemaVersion~ - This is a basic versioning system used for Genny workload syntax. For the moment, any new workloads should have the value ~2018-07-01~ for this key.
- ~Owner~ - This should have an identifier for the team that owns the workload, ideally an @-mentionable GitHub team.
- ~Description~ - This should contain a written description of the workload. It's recommended to go into as much detail as possible, since understanding the performance issue behind why a workload was written can be difficult months or years later.
- ~Keywords~ - These should be searchable keywords associated with your workload. Include keywords for actors used, operations performed, qualities of the system under test that are expected, etc.

Workload configurations can be found in [[file:../src/workloads][./src/workloads]] from the Genny repo root. Organization of this directory is arbitrary as far as Genny is concerned, though example workloads should be in the ~docs~ subdir.
*** What is an actor?
Genny uses an actor-based model for its workload generation. When execution begins, Genny spawns all configured actors in their own threads. Each actor can behave independently, be configured separately, and even has its own source code. In the example above, the following is the actor configuration:

#+BEGIN_SRC
Actors:
- Name: HelloWorldExample
  Type: HelloWorld
  Threads: 2
  Phases:
  - Message: Hello Phase 0 üê≥
    Duration: 50 milliseconds
  - Message: Hello Phase 1 üë¨
    Repeat: 100
#+END_SRC

In this example, there is a single ~HelloWorld~ actor allocated two threads. This actor moves through a series of phases, printing a message in each. Phases are described further in the next section. Each thread contains a complete "instance" of the actor, configured identically. We could add more actors like so:

#+BEGIN_SRC
Actors:
- Name: HelloWorldExample
  Type: HelloWorld
  Threads: 2
  Phases:
  - Message: Hello Phase 0 üê≥
    Duration: 50 milliseconds
  - Message: Hello Phase 1 üë¨
    Repeat: 100
- Name: InsertRemoveExample
  Type: InsertRemove
  Threads: 100
  Phases:
  - Duration: 10 milliseconds
  - Nop
#+END_SRC

This example has an additional ~InsertRemove~ actor with 100 threads, where each thread inserts and removes a document as fast as possible. Note that even though the actors are listed sequentially, all actors are concurrent.

Actor configurations expect the following keys:
- ~Name~ - The human-understandable name of this particular actor configuration. This should be unique throughout the workload.
- ~Type~ - The kind of actor to create. This determines the actor's behavior and possible configuration options.
- ~Threads~ - How many threads to allocate for this actor.
- ~Phases~ - A list of phase configurations (described in next section).

In addition to the universal fields above, individual actors may have their own configuration keys, such as the ~Message~ key of the ~HelloWorld~ actor, used to determine what message is printed.

Actors are written in C++, and creating new actors or extending existing ones is a common and encouraged workflow when using Genny. For more details, see [[* Creating an Actor][Creating an Actor]].
*** What is a phase?
Genny workloads and actors proceed in a sequence of phases, configured inside actors. In the running example, our ~HelloWorld~ actor is configured with two phases:

#+BEGIN_SRC
Actors:
- Name: HelloWorldExample
  Type: HelloWorld
  Threads: 2
  Phases:
  - Message: Hello Phase 0 üê≥
    Duration: 50 milliseconds
  - Message: Hello Phase 1 üë¨
    Repeat: 100
#+END_SRC

This actor will execute the first phase for 50 milleseconds. It will perform iterations of its main loop (printing "Hello Phase 0") as many times as it can for that duration. It will then move on to the second phase, where it will perform exactly 100 iterations of its main loop (printing "Hello Phase 1"), regardless of how long it takes. Then the workload will end.

Now consider a situation with two actors:

#+BEGIN_SRC
Actors:
- Name: HelloWorldExample
  Type: HelloWorld
  Threads: 2
  Phases:
  - Message: Hello Phase 0 üê≥
    Duration: 50 milliseconds
  - Message: Hello Phase 1 üë¨
    Repeat: 100
- Name: HelloWorldSecondExample
  Type: HelloWorld
  Threads: 1
  Phases:
  - Message: Other Actor Phase 0
    Duration: 10 milliseconds
  - Message: Other Actor Phase 1
    Duration: 10 milliseconds
#+END_SRC

Here we have the ~HelloWorldSecondExample~ actor running for 10 milliseconds in each phase. However, the second phase will not begin after 10 seconds. It's important to note that phases are coordinated globally, and actors configured with either ~Repeat~ or ~Duration~ will hold the phase open. In this case, ~HelloWorldSecondExample~ will operate for 10 milliseconds during the first phase, sleep for 40 milliseconds for the rest of the phase, then after ~HelloWorldExample~ finishes holding the phase open, both actors will begin the next phase.

Phase configurations accept the following main keys:
- ~Duration~ - How long to operate in this phase while holding the phase open.
- ~Repeat~ - How many times to repeat the operation while holding the phase open.
- ~Blocking~ - This key can be specified with the value ~None~ to cause the actor to run as a *background actor* for this phase. This actor will act as many times as possible during the phase without holding it open, then move on to the next phase when everyone else is ready.
- ~Nop~ - This key can be set with the value ~true~ to cause the actor to nop for the duration of the phase.

A couple of notes about the above:
- You can specify both ~Repeat~ and ~Duration~ for a phase. Whichever lasts longer wins.
- It is undefined behavior if a given phase does not have some actor specifying ~Repeat~ or ~Duration~.

**** Sleeping

In addition to the above keys, actors can also be configured to sleep during parts of phases. For example:

#+BEGIN_SRC
Actors:
- Name: HelloWorldExample
  Type: HelloWorld
  Threads: 2
  Phases:
  - SleepBefore: 10 milliseconds
    Message: Hello Phase 0 üê≥
    Duration: 50 milliseconds
    SleepAfter: 15 milliseconds
#+END_SRC

This will sleep for 10 milliseconds at the beginning of /every/ actor iteration and for 15 milliseconds at the end of every iteration. This time is counted as part of the phase duration. Genny accepts the following sleep configurations:

- ~SleepBefore~ - duration to sleep at the beginning of each iteration
- ~SleepAfter~ - duration to sleep after each iteration
  
**** Rate Limiting

By default, actors will repeat their main loop as quickly as possible. Sometimes you want to restrict how quickly an actor works. This can be done using a rate limiter:

#+BEGIN_SRC
Actors:
- Name: HelloWorldExample
  Type: HelloWorld
  Threads: 100
  Phases:
  - Message: Hello Phase 0
    GlobalRate: 5 per 10 milliseconds
    Duration: 50 milliseconds
#+END_SRC

Using the ~GlobalRate~ configuration, the above actor will only have 5 threads act every 10 milliseconds, despite having 100 threads that could reasonable act at once.

In addition to hard-coding how many threads act and when, you can configure Genny to rate-limit the actor at a percentage of the detected maximum rate:

#+BEGIN_SRC
Actors:
- Name: HelloWorldExample
  Type: HelloWorld
  Threads: 100
  Phases:
  - Message: Hello Phase 0
    GlobalRate: 80%
    Duration: 2 minutes
#+END_SRC

The above workload will run ~HelloWorldExample~ at maximum throughput for either 1 minutes or 3 iterations of the actor's loop, whichever is longer. Afterwards, Genny will use the estimated throughput from that time to limit the actor to 80% of the max throughput.

Note that the rate limiter uses a [[https://en.wikipedia.org/wiki/Token_bucket][token bucket algorithm]]. This means that bursty behavior is possible. For example, if we configure ~GlobalRate: 5 per 10 milliseconds~ then we will have 5 threads act all at once, followed by 9 or so milliseconds without any threads acting, then another burst of 5 threads acting, etc. We can smooth the rate by specifying a tighter yet equivalent rate limit: ~GlobalRate: 1 per 2 milliseconds~.

Since the percentage-based limiting treats the entire estimation period as the duration in the rate specification, it is highly prone to bursty behavior.

Rate limiting accepts the following configurations:
- ~GlobalRate~ - specified as either a rate specification (x per y minutes/seconds/milliseconds/etc) or as a percentage

*** How do I run a workload?

Workloads can be run with the following Genny command:

#+BEGIN_SRC
./run-genny workload <path_to_workload>
#+END_SRC

If your workload requires a MongoDB connection (most do), then you can pass it in with ~-u~. See [[*Connecting to the Server][Connecting to the Server]] for more details.

** Outputs
Genny's primary output is time-series data. Every time an actor performs an operation, such as an insert, a removal, a runcommand, etc, the actor thread starts a timer. When the operation returns from the server, the operation is recorded as either a success or failure. The duration of the operation, as viewed from the client, is recorded with the operation completion time.

Genny outputs to ~./build/WorkloadOutput~. When running Genny for the first time, you should see two outputs in that directory:
- ~CedarMetrics~ - a directory full of FTDC files, where each file corresponds to a single time-series metric for a single operation. For more details about the format and contents of these FTDC files, see our tool-agnostic documentation [[https://github.com/10gen/performance-tooling-docs/blob/main/getting_started/intrarun_data_generation.md][here]].
- ~workload~ - a directory containing the preprocessed workload. Learn more about the preprocessor [[*Preprocessor][here]].

If you run Genny and the ~CedarMetrics~ directory already exists, it will be moved to ~CedarMetrics-<current_time>~ to avoid overwriting results. The preprocessed workload will be deposited into the ~workload~ directory, possibly overwriting the existing one. (Or you may end up with multiple workloads in the directory, if they have different names. This has no impact on execution.)
** Workload Development
 1. Create a yaml file in ~./src/workloads~ in whatever topical subdirectory you deem appropriate and populate it with appropriate configuration. If you have yaml configuration that may need loading, place it in ~./src/phases~ (and for more details about what that means, see [[*Preprocessor][here]]). Consider whether existing actors can be repurposed for your workload, or whether a new one is needed. For the latter, see [[*Creating an Actor][here]].

    #+BEGIN_SRC
    vim src/workloads/<workload_dir>/<workload_name.yml>
    vim src/phases/<phase_dir>/<phases_name.yml> # Only necessary if creating external configuration
    ./run-genny create-new-actor  # Only necessary if creating a new actor
    #+END_SRC

 2. Run the self-tests:
    #+BEGIN_SRC
    ./run-genny lint-yaml  # Lint all YAML files
    ./run-genny cmake-test  # Run C++ Unit test - only necessary if editing core C++ code
    ./run-genny resmoke-test  # Run actor integration tests - only necessary if adding/editing actors
    #+END_SRC

 3. (Optional) If you can run your system under test locally, you can test against it as a sanity-check:
    #+BEGIN_SRC
    ./run-genny workload -u <connection_uri> src/workloads/<workload_dir/workload_name.yml>
    #+END_SRC

 4. (Optional) If you are using DSI, you can run your workload through it by copying or symlinking your Genny directory into your DSI workdir. See [[./run-dsi onboarding  # introductory DSI command; see link above for details][Running DSI Locally]] for details:
    #+BEGIN_SRC
    ./run-dsi onboarding  # introductory DSI command; see link above for details
    cd WORK
    rm -rf src/genny
    ln -s ~/<path_to_genny>/genny src
    vim bootstrap.yml
    #+END_SRC

 5. Before merging, you should run your workload in realistic situations in CI and check the resultant metrics. For Genny workloads run through DSI using [[*AutoRun][AutoRun]], you can create a patch using the following:

    #+BEGIN_SRC
    cd ~/<path_to_evg_project_repo>
    evergreen patch -p <evg_project>
    cd ~/<path_to_genny>/genny
    evergreen patch-set-module -i <patch_id_number> genny
    #+END_SRC

    You can then select ~schedule_patch_auto_tasks~ on a variant to schedule any modified or new Genny tasks created by AutoRun. Alternatively, you could select ~schedule_variant_auto_tasks~ to schedule all Genny tasks on that variant.

For more details on workload development, please check out our general docs on [[https://github.com/10gen/performance-tooling-docs/blob/main/new_workloads.md][Developing and Modifying Workloads]] and on [[https://github.com/10gen/performance-tooling-docs/blob/main/patch_testing.md][Basic Performance Patch Testing]].
* Further Concepts
** Common Actors
There are several actors owned by TIPS which are intended for widespread use:

- CrudActor - Used to perform CRUD operations, recording client-side metrics.
- RunCommand - Execute a command against the remote server. Often used for utility purposes, but metrics are collected as well.
- Loader - Load many documents into the remote database. Often used early in a workload to set the preconditions for testing. 
- QuiesceActor - Quiesce a cluster, making sure common operations are complete. This is often used to reduce noise between phases.

Examples with these and other actors can be found in [[file:../src/workloads/docs][./src/workloads/docs]].

** AutoRun
*** What is AutoRun?
AutoRun is a utility to allow workload authors to determine scheduling of their workloads without having to commit to a separate repo. The utility is specifically designed for users who are using DSI through Evergreen. To use AutoRun, make sure your project has integrated DSI with Evergreen as explained [[https://github.com/10gen/dsi/wiki/DSI-In-Evergreen][here]].

After performing the above integration, your Evergreen project should have a ~schedule_variant_auto_tasks~ task on each variant, which can be used to schedule all Genny workloads that are configured to run on this variant. There will also be the ~schedule_patch_auto_tasks~ task which will schedule any new or modified Genny workloads. If you want to run an unmodified workload, make a small edit (such as inserting whitespace) to force it to be picked up by that latter task.

Both of the above tasks will have a dependency on ~schedule_global_auto_tasks~, which invokes ~./run-genny auto-tasks~ to create all possible tasks, viewable in the ~TaskJson~ directory of that task's DSI artifacts. The variant-specific task generator task will then schedule the appropriate task, based on the workload configurations described below.
*** Configuring AutoRun
The ~schedule_variant_auto_tasks~ task automatically runs workloads based on the evergreen environment
(variables from ~bootstrap.yml~ and ~runtime.yml~ in DSI) and an optional AutoRun
section in any workload. The AutoRun section is a list of <When/ThenRun> blocks,
where if the When condition is met, tasks are scheduled with additional bootstrap
values from ThenRun. For example,
suppose we have a ~test_workload.yml~ file in a ~workloads/*/~ subdirectory,
containing the following AutoRun section:

#+BEGIN_SRC
AutoRun:
  - When:
      mongodb_setup:
        $eq:
          - replica
          - replica-noflowcontrol
      branch_name:
        $neq:
          - v4.0
          - v4.2
    ThenRun:
      - infrastructure_provisioning: foo
      - infrastructure_provisioning: bar
      - arbitrary_key: baz
#+END_SRC

In this case, it looks in the ~bootstrap.yml~ of ~test_workload~, checks if ~mongodb_setup~
is either ~replica~ or ~replica-noflowcontrol~, and also if ~branch_name~ is neither ~v4.0~ nor ~v4.2~.
If both conditions are true, then we schedule several tasks. Let's say the workload name is
~DemoWorkload~, 3 tasks are scheduled - ~demo_workload_foo~, ~demo_workload_bar~, and ~demo_workload_baz~.
The first task is passed in the bootstrap value ~infrastructure_provisioning: foo~, the second
is passed in ~infrastructure_provisioning: bar~ and the third ~arbitrary_key: baz~.

This is a more complex example of AutoRun. Here's a more simple one representing a more common usecase:

#+BEGIN_SRC
AutoRun:
  - When:
      mongodb_setup:
        $eq: standalone
#+END_SRC

Let's say this is ~DemoWorkload~ again. In this case, if ~mongodb_setup~ is ~standalone~
we schedule ~demo_workload~ with no additional params.

A few notes on the syntax:
- Supports multiple When/ThenRun blocks per AutoRun. Each are evaluated independently.
- When blocks can evaluate multiple conditions. All conditions must be true to schedule the task.
- When supports $eq and $neq. Both can accept either a scalar or list of values.
- For a list of values, $eq evaluates to true if it is equal to at least one.
- For a list of values, $neq evaluates to true if it is equal to none of the values.
- ThenRun blocks are optional.
    - **Most usecases do not need to use ThenRun**
    - If you do use ThenRun, please be judicious. If you have a task that is scheduled when
      mongodb_setup == replica, it would be confusing if mongodb_setup was overwritten to standalone.
      But it would be ok to overwrite mongodb_setup to replica-delay-mixed, as is done in the
      [ParallelWorkload][pi] workload.
- Each item in the ThenRun list can only support one {bootstrap_key: bootstrap_value} pair.
- If using ThenRun but you would also like to schedule a task without any bootstrap overrides,
  Add an extra pair to ThenRun with the original key/value, like done on line 189 [here][pi].
- If using ThenRun, the new task name becomes <taskname>_<bootstrap-value>. In the ParallelWorkload example,
  the task name becomes parallel_insert_replica_delay_mixed (name is automatically converted to snake_case).
  The bootstrap-key is not included in the name for the purpose of not changing existing names and
  thus deleting history. This may change after PM-2310.
** Generators
It is often necessary to use Genny to operate with large amounts of data which would be impractical to hardcode. Genny uses generators for this. A generator is a piece of code that generates pseudorandom values every time it is invoked, and which can be configured from the workload yaml. Notably, generators use a hardcoded seed, so repeated Genny executions should be deterministic with respect to generated values.

Generators are not a builtin feature of Genny, but must be integrated by each actor for the configuration values that accept them. For examples of using generators, see [[file:../src/workloads/docs/Generators.yml][./src/workloads/docs/Generators.yml]]. To integrate generators into an actor, use the [[../src/value_generators/include/value_generators/DocumentGenerator.hpp][DocumentGenerator]] with the yaml node you intend to generate documents from. (And see [[*Creating an Actor][here]] for more details on creating an actor in the first place.)
** Preprocessor
*** Evaluate
*** LoadConfig
*** Parameters
*** ActorTemplate
*** OnlyActiveInPhases
*** Overrides
** Connecting to the Server
** Conventions and Value Interpretation
** Creating an Actor
*** PhaseLoop
*** Gennylib API
*** Operations
*** Integration Tests
*** LINK: Developing in Genny
*** LINK: Contribution Guidelines
** Internal Metrics
** Pre-seeded Data
* Common Pitfalls (FAQ)
