SchemaVersion: 2018-07-01
Owner: "@mongodb/product-perf"

description: |
  TODO: This functionality does not exist yet. It will be implemented in PERF-2516.  The Curd Actor
  will support FSM definition, with operations associated with each states. Choices are declared
  with weights that are converted into probabilities.

  There is an initial state vector, with weight. Each actor instance will probabilistically and
  independently choose it's initial state based on the weights.

  Each state specifies a list of transitions. The next transition is picked probabilistically, based
  on the transition weights. Transitions may experience delay (sleepBefore), before changing the
  state. The state has associated operations which execute while the FSM remains in that
  state. (Question: what happens during the transition delay? I suggest nothing)

  By default the system will measure the latency to execute each set of operations associated with a
  state, and each individual operation.

  This example workload is a toy example modeling the state of 5 smart phones. The model has four
  states for each phone: On, Off, Sleep, and Error, and transitions between those states. In this
  example, there is monitoring for the smart phones, and the database gets updated based on the
  state of the phones and state changes. The workload (monitoring app) tracks the current phone
  state in one document per phone (update operations). Note that this is separate than the state
  machinery tracking of state.

Clients:
  Default:
    QueryOptions:
      maxPoolSize: 100

Actors:
# Preload some documents
- Name: SetupDemo
  Type: Crud
  Threads: 1
  Database: StateTest
  Phases:
  - Repeat: 1
    Collection: CrudDemo
    Operations:
    - OperationName: bulkWrite
      OperationCommand:
        WriteOperations:
        - WriteCommand: insertOne
          Document: {phoneID: 1, state: "Off"}
        - WriteCommand: insertOne
          Document: {phoneID: 2, state: "Off"}
        - WriteCommand: insertOne
          Document: {phoneID: 3, state: "Off"}
        - WriteCommand: insertOne
          Document: {phoneID: 4, state: "Off"}
        - WriteCommand: insertOne
          Document: {phoneID: 5, state: "Off"}
    - &nop {Nop: true}
    - *nop

- Name: StateSmartPhoneDemo
  Type: Crud
  Threads: 5
  Database: StateTest
  Phases:
  - *nop
  - Duration: 30 seconds
    Collection: CrudDemo
    States:
    - Name: "On"  # The device is on

      # The states support the keywords Repeat, SleepBefore, SleepAfter, (local) Rate, and
      # Duration. These keywords behave the same as in Phase Control, but operate per state (i.e.,
      # per actor instance as it goes through the state machine.
      Repeat: 1
      Operations:
      # A state can have (optional) a set of operations that execute upon entering the state. This
      # state updates a specific document to indicate it is in state On.

      # Note: Following the analogy to phases -- phases may be blocking or non-blocking. States are
      # always non-blocking. When the phase ends, the state machine will finish any open operations,
      # and then exit. It if is waiting for a delay, it will exit immediately. This is required as
      # there may be states with long delays.
      # Question: Should we support having a single fire operation with repeating operations? Here I
      # could invent a case where the following operation is repeat 1, but there is another
      # operation that repeats once a second while in this state. I don't know how to represent
      # that.
      - OperationName: updateOne
        OperationCommand:
          Filter: &filter {phoneID: {^ActorId: {}}}
          Update:
            $set: {state: "On"}

      # Transitions specifies next states, delays, and operations. The On state can transition to
      # each of the three other states
      Transitions:
      - To: "Off"  # Transition to this state

        # Transitions are probabilistically chosen based on weight. A transition with weight 2 is
        # twice as likely to be picked as a transition with weight 1. Weights must be greater than
        # 0.
        Weight: 1

        # Transitions also support the phase keywords of sleepBefore, sleepAfter, and repeat.
        # ^TimeSpec is a proposed generator to randomly generate acceptable TimeSpecs with units. It
        # accepts any valid int or double generator or constant for value.
        SleepBefore: {^TimeSpec: {value: {^RandomDouble: {min: 0, max: 15}}, unit: "seconds"}}

    - Name: "Off"  # The device is Off
      Operations:
      - OperationName: updateOne
        OperationCommand:
          Filter: *filter
          Update:
            $set: {state: "Off"}
      Transitions:  # Can only go to On from Off
      - To: "On"
        Weight: 1
        SleepBefore: {^TimeSpec: {value: {^RandomDouble: {min: 0, max: 15}}, unit: "seconds"}}

    - Name: Sleep
      Operations:
      - OperationName: updateOne
        OperationCommand:
          Filter: *filter
          Update:
            $set: {state: "Sleep"}
      Transitions:  # Can only go to On or Off from sleep
      - To: "On"
        Weight: 1
        SleepBefore: {^TimeSpec: {value: {^RandomDouble: {min: 0, max: 15}}, unit: "seconds"}}
      - To: "Off"
        Weight: 1
        SleepBefore: {^TimeSpec: {value: {^RandomDouble: {min: 0, max: 15}}, unit: "seconds"}}

    - Name: Error
      Operations:
      - OperationName: updateOne
        OperationCommand:
          Filter: *filter
          Update:
            $set: {state: "Error"}
      Transitions:  # Turn off on error
      - To: "Off"
        Weight: 1
        SleepBefore: {^TimeSpec: {value: {^RandomDouble: {min: 0, max: 15}}, unit: "seconds"}}

    # In this example we always start in the off State
    InitialStates:
    - "Off":
        Weight: 1
