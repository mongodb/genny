SchemaVersion: 2018-07-01
Owner: "@mongodb/query"
Description: |
  This workload tests the performance of the $densify stage with a numeric step. The workload
  should be kept in sync with the other Densify[Unit] workloads in this directory.

  Each densify workload has a metric to cover possible codepaths through the densify stage, namely
  different bounds types and whether or not to generate documents along partitions.
  
  Since $densify is a new aggregation stage, there isn't a known "good" runtime for aggregations 
  that include it. Rather than comparing against a baseline initially, workloads with different 
  options that generate similar numbers of documents will be compared to ensure that there isn't an
  option that relies on a specific codepath that slows down one kind of densification more than another.

  Initial investigation has shown that holding other options equal, numeric and millisecond step units
  have similar latencies, and all other step units have larger latencies which are all similar to each other.
  This is due to the need for date arithmetic to perform extra processing to add an interval of a
  certain size to a date. Since dates are stored as milliseconds since the Unix epoch under the hood,
  the millisecond step unit can skip most of this processing and just performs the same arithmetic
  as the numeric step unit.

  The working assumption is that latency will scale linearly with the number of documents generated 
  by the $densify stage: If N is the number of documents in the collection, and M is the number of
  documents generated by $densify, then the theoretical runtime should be O(N+M).

  The factors that affect the number of documents generated include, but are not limited to:

  - The range that is being densified. This is pretty self-evident, the larger the range that $densify
    is working over, the more documents will be generated. This includes large ranges specified 
    explicitly in the bounds option, and implicitly large ranges when densifying over collections
    where the minimum and maximum documents are farther from each other in the 
    `bounds: "full"|"partition"` cases.

  - The step size. Smaller steps produce more documents when the range is held constant.

  - The cardinality of the fields specified in the `partitionByFields`, if set. One document
    will be generated with every value within the range for each partition, so the higher the 
    cardinality, the more documents that will be generated. Specifying a `partitionByFields` will
    never decrease the number of documents generated, holding all other options equal.


Actors:
- Name: InsertData
  Type: Loader
  Threads: 1
  Phases:
  - Repeat: 1
    Database: &db test
    Threads: 1
    CollectionCount: 1
    DocumentCount: 10000
    BatchSize: &batchSize 30000 
    Document:
      partitionKey: {^RandomInt: {min: 1, max: 100}}
      # Test a subset of units that have different characteristics.
      number: {^RandomInt: {min: 0, max: 20000}} # Seperate codepath for numeric DensifyValues.
      milliseconds: {^RandomDate: {min: "2021-01-01T00:00:00.000Z", max: "2021-01-01T00:00:20.000Z"}} # Most basic date unit.
      hours: {^RandomDate: {min: "2021-01-01", max: "2023-01-01"}} # Date unit with constant number of milliseconds.
      months: {^RandomDate: {min: "2021-01-01", max: "4000-01-01"}} # Date unit with non-constant number of milliseconds.
    # $densify stages always add a $sort on the field that is being densified, so this phase adds 
    # indexes on the date/number fields so that we aren't performing an in-memory sort.    
    Indexes:
    - keys: {number: 1}
      options: {name: "numeric"}
  - &Nop {Nop: true}
  - *Nop

- Name: Quiesce
  Type: QuiesceActor
  Threads: 1
  Database: *db
  Phases:
  - *Nop
  - Repeat: 1
  - *Nop

- Name: Densify
  Type: RunCommand
  Threads: 1
  Phases:
  - *Nop
  - *Nop
  - Repeat: 10
    Database: *db
    Operations:

    # Metrics are grouped by the step unit they operate with (numeric, millisecond, hour, month).
    # Each group has a metric for each possible codepath (Partition/no partition, explicit/full/partitioned bounds).

    # Numeric metrics. 
    - OperationMetricsName: FullDensifySmallStep
      OperationName: RunCommand
      OperationCommand:
        aggregate: Collection0
        pipeline: [{
          $densify: {
            field: "number", 
            range: {
              bounds: "full", 
              step: &smallStep 3
            }
          }
        }]
        cursor: {batchSize: *batchSize}
    - OperationMetricsName: FullDensifyLargeStep
      OperationName: RunCommand
      OperationCommand:
        aggregate: Collection0
        pipeline: [{
          $densify: {
            field: "number", 
            range: {
              bounds: "full", 
              step: &largeStep 8
            }
          }
        }]
        cursor: {batchSize: *batchSize}
    - OperationMetricsName: FullDensifyByPartitionSmallStep
      OperationName: RunCommand
      OperationCommand:
        aggregate: Collection0
        pipeline: [{
          $densify: {
            field: "number", 
            partitionByFields: ["partitionKey"], 
            range: {
              bounds: "full", 
              step: *smallStep
            }
          }
        }]
        cursor: {batchSize: *batchSize}
    - OperationMetricsName: FullDensifyByPartitionLargeStep
      OperationName: RunCommand
      OperationCommand:
        aggregate: Collection0
        pipeline: [{
          $densify: {
            field: "number", 
            partitionByFields: ["partitionKey"], 
            range: {
              bounds: "full", 
              step: *largeStep
            }
          }
        }]
        cursor: {batchSize: *batchSize}
    - OperationMetricsName: PartitionedDensifyByPartitionSmallStep
      OperationName: RunCommand
      OperationCommand:
        aggregate: Collection0
        pipeline: [{
          $densify: {
            field: "number", 
            partitionByFields: ["partitionKey"], 
            range: {
              bounds: "partition", 
              step: *smallStep
            }
          }
        }]
        cursor: {batchSize: *batchSize}
    - OperationMetricsName: PartitionedDensifyByPartitionLargeStep
      OperationName: RunCommand
      OperationCommand:
        aggregate: Collection0
        pipeline: [{
          $densify: {
            field: "number", 
            partitionByFields: ["partitionKey"], 
            range: {
              bounds: "partition", 
              step: *largeStep
            }
          }
        }]
        cursor: {batchSize: *batchSize}
    - OperationMetricsName: ExplicitRangeDensifySmallStep
      OperationName: RunCommand
      OperationCommand:
        aggregate: Collection0
        pipeline: [{
          $densify: {
            field: "number", 
            range: {
              step: *smallStep, 
              bounds: &numericBounds [{^RandomInt: {min: 5000, max: 15000}}, {^RandomInt: {min: 20000, max: 40000}}]
            }
          }
        }]
        cursor: {batchSize: *batchSize}
    - OperationMetricsName: ExplicitRangeDensifyLargeStep
      OperationName: RunCommand
      OperationCommand:
        aggregate: Collection0
        pipeline: [{
          $densify: {
            field: "number", 
            range: {
              step: *largeStep, 
              bounds: *numericBounds
            }
          }
        }]
        cursor: {batchSize: *batchSize}
    - OperationMetricsName: ExplicitRangeDensifyByPartitionSmallStep
      OperationName: RunCommand
      OperationCommand:
        aggregate: Collection0
        pipeline: [{
          $densify: {
            field: "number", 
            partitionByFields: ["partitionKey"], 
            range: {
              step: *smallStep, 
              bounds: *numericBounds
            }
          }
        }]
        cursor: {batchSize: *batchSize}
    - OperationMetricsName: ExplicitRangeDensifyByPartitionLargeStep
      OperationName: RunCommand
      OperationCommand:
        aggregate: Collection0
        pipeline: [{
          $densify: {
            field: "number", 
            partitionByFields: ["partitionKey"], 
            range: {
              step: *largeStep, 
              bounds: *numericBounds
            }
          }
        }]
        cursor: {batchSize: *batchSize}

AutoRun:
- When:
    mongodb_setup:
      $eq:
      - replica
      - replica-all-feature-flags
    branch_name:
      $neq:
      - v4.0
      - v4.2
      - v4.4
      - v5.0
