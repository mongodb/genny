SchemaVersion: 2018-07-01
Owner: "@mongodb/query"
Description: |
  This workload tests the performance of the $densify stage with month-long step intervals.
  The text of each Densify[Unit] workload is identical from from the Actors list to the end of the
  file, with all workload-specific details defined as anchors under the GlobalDefaults key. Any
  changes to the actors should make use of these anchors and be copy-pasted between the Densify[Unit]
  workloads to keep them in sync.

  Each densify workload has a metric to cover possible codepaths through the densify stage, namely
  different bounds types and whether or not to generate documents along partitions.  
  
  Since $densify is a new aggregation stage, there isn't a known "good" runtime for aggregations 
  that include it. Rather than comparing against a baseline initially, workloads with different 
  options that generate similar numbers of documents will be compared to ensure that there isn't an
  option that relies on a specific codepath that slows down one kind of densification more than another.

  Initial investigation has shown that holding other options equal, numeric and millisecond step units
  have similar latencies, and all other step units have larger latencies which are all similar to each other.
  This is due to the need for date arithmetic to perform extra processing to add an interval of a
  certain size to a date. Since dates are stored as milliseconds since the Unix epoch under the hood,
  the millisecond step unit can skip most of this processing and just performs the same arithmetic
  as the numeric step unit.

  The working assumption is that latency will scale linearly with the number of documents generated 
  by the $densify stage: If N is the number of documents in the collection, and M is the number of
  documents generated by $densify, then the theoretical runtime should be O(N+M).

  The factors that affect the number of documents generated include, but are not limited to:

  - The range that is being densified. This is pretty self-evident, the larger the range that $densify
    is working over, the more documents will be generated. This includes large ranges specified 
    explicitly in the bounds option, and implicitly large ranges when densifying over collections
    where the minimum and maximum documents are farther from each other in the 
    `bounds: "full"|"partition"` cases.

  - The step size. Smaller steps produce more documents when the range is held constant.

  - The cardinality of the fields specified in the `partitionByFields`, if set. One document
    will be generated with every value within the range for each partition, so the higher the 
    cardinality, the more documents that will be generated. Specifying a `partitionByFields` will
    never decrease the number of documents generated, holding all other options equal. 

GlobalDefaults:
  dbname: &db test
  MaxPhases: &MaxPhases 20
  batchSize: &batchSize 5000
  fieldName: &field "months"
  unitName: &unit "month" 
  index: &index
    keys: {months: 1}
    options: {name: "month"}
  smallStepSize: &smallStep 3
  largeStepSize: &largeStep 8
  explicitBounds: &bounds [
    {^RandomDate: {min: "2500-01-01", max: "3500-01-01"}}, 
    {^RandomDate: {min: "4000-01-01", max: "5500-01-01"}}
  ]

Actors:
- Name: InsertData
  Type: Loader
  Threads: 1
  Phases:
    OnlyActiveInPhases:
      Active: [0]
      NopInPhasesUpTo: *MaxPhases
      PhaseConfig:
        Repeat: 1
        Database: *db
        Threads: 1
        CollectionCount: 1
        DocumentCount: 10000
        BatchSize: *batchSize 
        Document:
          partitionKey: {^RandomInt: {min: 1, max: 100}}
          # Test a subset of units that have different characteristics.
          number: {^RandomInt: {min: 0, max: 20000}} # Seperate codepath for numeric DensifyValues.
          milliseconds: {^RandomDate: {min: "2021-01-01T00:00:00.000Z", max: "2021-01-01T00:00:20.000Z"}} # Most basic date unit.
          hours: {^RandomDate: {min: "2021-01-01", max: "2023-01-01"}} # Date unit with constant number of milliseconds.
          months: {^RandomDate: {min: "2021-01-01", max: "4000-01-01"}} # Date unit with non-constant number of milliseconds.
        # $densify stages always add a $sort on the field that is being densified, so this phase adds 
        # indexes on the date/number fields so that we aren't performing an in-memory sort.    
        Indexes:
        - *index

- Name: Quiesce
  Type: QuiesceActor
  Threads: 1
  Database: *db
  Phases:
    OnlyActiveInPhases:
      Active: [1]
      NopInPhasesUpTo: *MaxPhases
      PhaseConfig:
        Repeat: 1

- Name: FullSmallStep
  Type: CollectionScanner
  Threads: 1
  Database: Collection0
  Phases:
    OnlyActiveInPhases:
      Active: [2]
      NopInPhasesUpTo: *MaxPhases
      PhaseConfig: 
        ScanType: standard
        Repeat: 10
        AggregatePipeline:
          {array: [
          {
            "$densify": {
              "field": *field,
              "range": {
                "bounds": "full",
                "step": *smallStep,
                "unit": *unit
              }
            }
          }
        ]}
        AggregateOptions:
          BatchSize: *batchSize
    

- Name: FullLargeStep
  Type: CollectionScanner
  Threads: 1
  Database: Collection0
  Phases:
    OnlyActiveInPhases:
      Active: [3]
      NopInPhasesUpTo: *MaxPhases
      PhaseConfig: 
        ScanType: standard
        Repeat: 10
        AggregatePipeline:
          {array: [
          {
            "$densify": {
              "field": *field,
              "range": {
                "bounds": "full",
                "step": *largeStep,
                "unit": *unit
              }
            }
          }
        ]}
        AggregateOptions:
          BatchSize: *batchSize
    

- Name: FullByPartitionSmallStep
  Type: CollectionScanner
  Threads: 1
  Database: Collection0
  Phases:
    OnlyActiveInPhases:
      Active: [4]
      NopInPhasesUpTo: *MaxPhases
      PhaseConfig: 
        ScanType: standard
        Repeat: 10
        AggregatePipeline:
          {array: [
          {
            "$densify": {
              "field": *field,
              "range": {
                "bounds": "full",
                "step": *smallStep,
                "unit": *unit
              },
              "partitionByFields": [
                "partitionKey"
              ]
            }
          }
        ]}
        AggregateOptions:
          BatchSize: *batchSize
    

- Name: FullByPartitionLargeStep
  Type: CollectionScanner
  Threads: 1
  Database: Collection0
  Phases:
    OnlyActiveInPhases:
      Active: [5]
      NopInPhasesUpTo: *MaxPhases
      PhaseConfig: 
        ScanType: standard
        Repeat: 10
        AggregatePipeline:
          {array: [
          {
            "$densify": {
              "field": *field,
              "range": {
                "bounds": "full",
                "step": *largeStep,
                "unit": *unit
              },
              "partitionByFields": [
                "partitionKey"
              ]
            }
          }
        ]}
        AggregateOptions:
          BatchSize: *batchSize
    

- Name: PartitionedByPartitionSmallStep
  Type: CollectionScanner
  Threads: 1
  Database: Collection0
  Phases:
    OnlyActiveInPhases:
      Active: [6]
      NopInPhasesUpTo: *MaxPhases
      PhaseConfig: 
        ScanType: standard
        Repeat: 10
        AggregatePipeline:
          {array: [
          {
            "$densify": {
              "field": *field,
              "range": {
                "bounds": "partition",
                "step": *smallStep,
                "unit": *unit
              },
              "partitionByFields": [
                "partitionKey"
              ]
            }
          }
        ]}
        AggregateOptions:
          BatchSize: *batchSize
    

- Name: PartitionedByPartitionLargeStep
  Type: CollectionScanner
  Threads: 1
  Database: Collection0
  Phases:
    OnlyActiveInPhases:
      Active: [7]
      NopInPhasesUpTo: *MaxPhases
      PhaseConfig: 
        ScanType: standard
        Repeat: 10
        AggregatePipeline:
          {array: [
          {
            "$densify": {
              "field": *field,
              "range": {
                "bounds": "partition",
                "step": *largeStep,
                "unit": *unit
              },
              "partitionByFields": [
                "partitionKey"
              ]
            }
          }
        ]}
        AggregateOptions:
          BatchSize: *batchSize
    

- Name: ExplicitRangeSmallStep
  Type: CollectionScanner
  Threads: 1
  Database: Collection0
  Phases:
    OnlyActiveInPhases:
      Active: [8]
      NopInPhasesUpTo: *MaxPhases
      PhaseConfig: 
        ScanType: standard
        Repeat: 10
        AggregatePipeline:
          {array: [
          {
            "$densify": {
              "field": *field,
              "range": {
                "bounds": *bounds,
                "step": *smallStep,
                "unit": *unit
              }
            }
          }
        ]}
        AggregateOptions:
          BatchSize: *batchSize
    

- Name: ExplicitRangeLargeStep
  Type: CollectionScanner
  Threads: 1
  Database: Collection0
  Phases:
    OnlyActiveInPhases:
      Active: [9]
      NopInPhasesUpTo: *MaxPhases
      PhaseConfig: 
        ScanType: standard
        Repeat: 10
        AggregatePipeline:
          {array: [
          {
            "$densify": {
              "field": *field,
              "range": {
                "bounds": *bounds,
                "step": *largeStep,
                "unit": *unit
              }
            }
          }
        ]}
        AggregateOptions:
          BatchSize: *batchSize
    

- Name: ExplicitRangeByPartitionSmallStep
  Type: CollectionScanner
  Threads: 1
  Database: Collection0
  Phases:
    OnlyActiveInPhases:
      Active: [10]
      NopInPhasesUpTo: *MaxPhases
      PhaseConfig: 
        ScanType: standard
        Repeat: 10
        AggregatePipeline:
          {array: [
          {
            "$densify": {
              "field": *field,
              "range": {
                "bounds": *bounds,
                "step": *smallStep,
                "unit": *unit
              },
              "partitionByFields": [
                "partitionKey"
              ]
            }
          }
        ]}
        AggregateOptions:
          BatchSize: *batchSize
    

- Name: ExplicitRangeByPartitionLargeStep
  Type: CollectionScanner
  Threads: 1
  Database: Collection0
  Phases:
    OnlyActiveInPhases:
      Active: [11]
      NopInPhasesUpTo: *MaxPhases
      PhaseConfig: 
        ScanType: standard
        Repeat: 10
        AggregatePipeline:
          {array: [
          {
            "$densify": {
              "field": *field,
              "range": {
                "bounds": *bounds,
                "step": *largeStep,
                "unit": *unit
              },
              "partitionByFields": [
                "partitionKey"
              ]
            }
          }
        ]}
        AggregateOptions:
          BatchSize: *batchSize

AutoRun:
- When:
    mongodb_setup:
      $eq:
      - replica
      - replica-all-feature-flags
    branch_name:
      $neq:
      - v4.0
      - v4.2
      - v4.4
      - v5.0
