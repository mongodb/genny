SchemaVersion: 2018-07-01
Owner: "@mongodb/query-integration"
Description: |
  This test stress tests bucket unpacking. Each document is large with many top-level fields.
  Each query targets a measurement, and cannot use the index on time/meta for time-series collections.
  Each query will target a different number of buckets, and we should see the runtime for each query
  increase based on the number of buckets unpacked.

Keywords:
  - timeseries
  - aggregate

GlobalDefaults:
  Database: &database test
  Collection: &collection Collection0
  maxPhases: &maxPhases 10
  Repeat: &repeat 100

ActorTemplates:
- TemplateName: RunMatchProjectPipeline
  Config:
    Name: {^Parameter: {Name: "Name", Default: "RunMatchProjectPipeline"}}
    Type: CrudActor
    Threads: 10
    Phases:
      OnlyActiveInPhases:
        Active: [{^Parameter: {Name: "Active", Default: 1000}}]
        NopInPhasesUpTo: *maxPhases
        PhaseConfig:
          Repeat: *repeat
          Database: *database
          Collection: *collection
          Operations:
          - OperationName: aggregate
            OperationCommand:
              Pipeline: [
                    {
                      $match:
                        {
                          "measurement0":
                            {
                              $lte:
                                {
                                  ^Parameter:
                                    { Name: "Predicate", Default: 0 },
                                },
                            },
                        },
                    },
                    {
                      $project:
                        {
                          _id: 1,
                          time: 1,
                          measurement0: 1,
                          payload1: 1,
                          payload2: 1,
                          payload5: 1,
                          payload6: 1,
                        },
                    },
                  ]

Actors:
  # Clear any pre-existing collection state. This is helpful to avoid errors during local testing.
  - Name: ClearCollection
    Type: CrudActor
    Database: *database
    Threads: 1
    Phases:
      OnlyActiveInPhases:
        Active: [0]
        NopInPhasesUpTo: *maxPhases
        PhaseConfig:
          Repeat: 1
          Threads: 1
          Collection: *collection
          Operations:
            - OperationName: drop

  - Name: CreateTimeSeriesCollection
    Type: RunCommand
    Threads: 1
    Phases:
      OnlyActiveInPhases:
        Active: [1]
        NopInPhasesUpTo: *maxPhases
        PhaseConfig:
          Repeat: 1
          Database: *database
          Operation:
            OperationMetricsName: CreateTimeSeriesCollection
            OperationName: RunCommand
            OperationCommand:
              { create: *collection, timeseries: { timeField: "time" } }

  - Name: InsertData
    Type: Loader
    Threads: 1
    Phases:
      OnlyActiveInPhases:
        Active: [2]
        NopInPhasesUpTo: *maxPhases
        PhaseConfig:
          Repeat: 1
          Database: *database
          CollectionCount: 1
          Threads: 1
          DocumentCount: 1000000
          BatchSize: 1000
          Document:
            # Since step = 900 ms and documentCount = 1,000,000, the first and last document
            # would be 900,000,000 ms apart (roughly 10 days).
            # Add events in this way means we have no out-of-order events and neat buckets. However, this is acceptable for this workload,
            # because we are testing the speed of bucket unpacking. Inserting documents in order allows us to deterministically control how
            # many documents are in each bucket, the number of overall buckets, and how many buckets each predicate will unpack.
            time: { ^IncDate: { start: "2022-01-01", step: 900 } }
            temp: { ^RandomDouble: { min: -30, max: 120 } }
            # This is the value we are going to query against. We will have ~1600 buckets in this
            # collection and roughly 600 documents per bucket. By making this an increasing value, we can write
            # predicates to target certain number of buckets.
            measurement: { ^Inc: { start: 1 } }
            # The fields below create larger documents to stress unpacking.
            payload1: { ^RandomDouble: { min: -100.0, max: 900.00 } }
            payload2: { ^RandomString: { length: 10 } }
            payload3:
              { ^Array: { of: { ^Choose: { from: [1, 2, 3] } }, number: 6 } }
            payload4: { ^RandomString: { length: 15 } }
            payload5: { ^RandomString: { length: 20 } }
            payload6: { ^RandomString: { length: 5 } }

  - Name: Quiesce
    Type: QuiesceActor
    Threads: 1
    Database: *database
    Phases:
      OnlyActiveInPhases:
        Active: [3]
        NopInPhasesUpTo: *maxPhases
        PhaseConfig:
          Repeat: 1

  # Run queries that target a different number of buckets.
  - ActorFromTemplate:
      TemplateName: RunMatchProjectPipeline
      TemplateParameters:
        Name: "SimpleMatchMeasurement10Buckets"
        Active: 4
        # With 600 documents per bucket, 10 buckets will have 'measurement0' <= 6000 (600 * 10).
        Predicate: 6000

  - ActorFromTemplate:
      TemplateName: RunMatchProjectPipeline
      TemplateParameters:
        Name: "MatchTarget100Buckets"
        Active: 4
        # With 600 documents per bucket, 100 buckets will have 'measurement0' <= 60000 (600 * 100).
        Predicate: 60000

  - ActorFromTemplate:
      TemplateName: RunMatchProjectPipeline
      TemplateParameters:
        Name: "MatchTarget1000Buckets"
        Active: 4
        # With 600 documents per bucket, 1000 buckets will have 'measurement0' <= 600000 (600 * 1000).
        Predicate: 600000

AutoRun:
  - When:
      mongodb_setup:
        $eq:
          - standalone-all-feature-flags
          - standalone
      branch_name:
        $neq:
          - v4.0
          - v4.2
          - v4.4
          - v5.0
