SchemaVersion: 2018-07-01
Owner: "@mongodb/query-integration"
Description: |
  This test stress tests bucket unpacking. Each document is large with many top-level fields.
  Each query targets a measurement, and cannot use the index on time/meta for time-series collections.
  Each query will target a different number of buckets, and we should see the runtime for each query
  increases based on the number of buckets to unpack.

Keywords:
  - timeseries
  - aggregate
  - unpack

GlobalDefaults:
  Database: &database test
  Collection: &collection Collection0
  maxPhases: &maxPhases 10
  Repeat: &repeat 5

Actors:
  # Clear any pre-existing collection state. This is helpful to avoid errors during local testing.
  - Name: ClearCollection
    Type: CrudActor
    Database: *database
    Threads: 1
    Phases:
      OnlyActiveInPhases:
        Active: [0]
        NopInPhasesUpTo: *maxPhases
        PhaseConfig:
          Repeat: 1
          Threads: 1
          Collection: *collection
          Operations:
            - OperationName: drop

  - Name: CreateTimeSeriesCollection
    Type: RunCommand
    Threads: 1
    Phases:
      OnlyActiveInPhases:
        Active: [1]
        NopInPhasesUpTo: *maxPhases
        PhaseConfig:
          Repeat: 1
          Database: *database
          Operation:
            OperationMetricsName: CreateTimeSeriesCollection
            OperationName: RunCommand
            OperationCommand:
              { create: *collection, timeseries: { timeField: "time" } }

  - Name: InsertData
    Type: Loader
    Threads: 1
    Phases:
      OnlyActiveInPhases:
        Active: [2]
        NopInPhasesUpTo: *maxPhases
        PhaseConfig:
          Repeat: 1
          Database: *database
          CollectionCount: 1
          Threads: 1
          DocumentCount: 1000000
          BatchSize: 1000
          Document:
            # Since step = 900 ms and documentCount = 1,000,000, the first and last document would be 900,000,000 ms apart (roughly 10 days).
            time: { ^IncDate: { start: "2022-01-01", step: 900 } }
            temp: { ^RandomDouble: { min: -30, max: 120 } }
            # This is the value we are going to query against. We will have ~1600 buckets in this collection and roughly 600 documents per bucket.
            # By making this an increasing value, we can write predicates to target certain number of buckets.
            measurement0: { ^Inc: { start: 1 } }
            # The fields below create larger documents to stress unpacking.
            measurement1: { ^RandomDouble: { min: -100.0, max: 900.00 } }
            measurement2: { ^RandomString: { length: 10 } }
            measurement3:
              { ^Array: { of: { ^Choose: { from: [1, 2, 3] } }, number: 6 } }
            measurement4: { ^RandomString: { length: 15 } }
            measurement5: { ^RandomString: { length: 20 } }
            measurement6: { ^RandomString: { length: 5 } }

  - Name: Quiesce
    Type: QuiesceActor
    Threads: 1
    Database: *database
    Phases:
      OnlyActiveInPhases:
        Active: [3]
        NopInPhasesUpTo: *maxPhases
        PhaseConfig:
          Repeat: 1

  # Run queries that target a different number of buckets.
  - Name: SimpleMatchMeasurement10Buckets
    Type: CrudActor
    Database: *database
    Threads: 10
    Phases:
      OnlyActiveInPhases:
        Active: [4]
        NopInPhasesUpTo: *maxPhases
        PhaseConfig:
          Repeat: *repeat
          Database: *database
          Collection: *collection
          Operations:
            - OperationMetricsName:
              OperationName: aggregate
              OperationCommand:
                # With 600 documents per bucket, 10 buckets will have 'measurement0' <= 6000 (600 * 10). We'll add 100 just to be safe.
                Pipeline: [{ $match: { "measurement0": { $lte: 6100 } } }]

  - Name: ConjunctionMatchMeasurement10Buckets
    Type: CrudActor
    Database: *database
    Threads: 10
    Phases:
      OnlyActiveInPhases:
        Active: [5]
        NopInPhasesUpTo: *maxPhases
        PhaseConfig:
          Repeat: *repeat
          Database: *database
          Collection: *collection
          Operations:
            - OperationMetricsName:
              OperationName: aggregate
              OperationCommand:
                # With 600 documents per bucket, 10 buckets will have 6000 <= 'measurement0' <= 12000 (6000 + 6000).
                Pipeline:
                  [
                    {
                      $match:
                        {
                          $and:
                            [
                              { "measurement0": { $gt: 6000 } },
                              { "measurement0": { $lte: 12100 } },
                            ],
                        },
                    },
                  ]

  - Name: MatchTarget100Buckets
    Type: CrudActor
    Database: *database
    Threads: 10
    Phases:
      OnlyActiveInPhases:
        Active: [6]
        NopInPhasesUpTo: *maxPhases
        PhaseConfig:
          Repeat: *repeat
          Database: *database
          Collection: *collection
          Operations:
            - OperationMetricsName:
              OperationName: aggregate
              OperationCommand:
                # With 600 documents per bucket, 100 buckets will have 'measurement0' <= 60000 (600 * 100). We'll add 100 just to be safe.
                Pipeline: [{ $match: { "measurement0": { $gt: 60100 } } }]

  - Name: ConjunctionMatchMeasurement100Buckets
    Type: CrudActor
    Database: *database
    Threads: 10
    Phases:
      OnlyActiveInPhases:
        Active: [7]
        NopInPhasesUpTo: *maxPhases
        PhaseConfig:
          Repeat: *repeat
          Database: *database
          Collection: *collection
          Operations:
            - OperationMetricsName:
              OperationName: aggregate
              OperationCommand:
                # With 600 documents per bucket, 100 buckets will have 6000 <= 'measurement0' <= 66000 (6000 + 600 * 100).
                Pipeline:
                  [
                    {
                      $match:
                        {
                          $and:
                            [
                              { "measurement0": { $gt: 6000 } },
                              { "measurement0": { $lte: 66100 } },
                            ],
                        },
                    },
                  ]

  - Name: MatchTarget1000Buckets
    Type: CrudActor
    Database: *database
    Threads: 10
    Phases:
      OnlyActiveInPhases:
        Active: [8]
        NopInPhasesUpTo: *maxPhases
        PhaseConfig:
          Repeat: *repeat
          Database: *database
          Collection: *collection
          Operations:
            - OperationMetricsName:
              OperationName: aggregate
              OperationCommand:
                # With 600 documents per bucket, 1000 buckets will have 'measurement0' <= 600000 (600 * 1000).
                Pipeline: [{ $match: { "measurement0": { $gte: 600100 } } }]

AutoRun:
  - When:
      mongodb_setup:
        $eq:
          - standalone-all-feature-flags
      branch_name:
        $neq:
          - v4.0
          - v4.2
          - v4.4
          - v5.0
          - v6.0
