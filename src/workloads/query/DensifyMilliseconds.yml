SchemaVersion: 2018-07-01
Owner: "@mongodb/query"
Description: |
  This workload tests the performance of the $densify stage with millisecond step intervals.
  The text of each Densify[Unit] workload is identical from from the Actors list to the end of the
  file, with all workload-specific details defined as anchors under the GlobalDefaults key. Any
  changes to the actors should make use of these anchors and be copy-pasted between the Densify[Unit]
  workloads to keep them in sync.

  Each densify workload has a metric to cover possible codepaths through the densify stage, namely
  different bounds types and whether or not to generate documents along partitions.


  Since $densify is a new aggregation stage, there isn't a known "good" runtime for aggregations
  that include it. Rather than comparing against a baseline initially, workloads with different
  options that generate similar numbers of documents will be compared to ensure that there isn't an
  option that relies on a specific codepath that slows down one kind of densification more than another.

  Initial investigation has shown that holding other options equal, numeric and millisecond step units
  have similar latencies, and all other step units have larger latencies which are all similar to each other.
  This is due to the need for date arithmetic to perform extra processing to add an interval of a
  certain size to a date. Since dates are stored as milliseconds since the Unix epoch under the hood,
  the millisecond step unit can skip most of this processing and just performs the same arithmetic
  as the numeric step unit.

  The working assumption is that latency will scale linearly with the number of documents generated
  by the $densify stage: If N is the number of documents in the collection, and M is the number of
  documents generated by $densify, then the theoretical runtime should be O(N+M).

  The factors that affect the number of documents generated include, but are not limited to:

  - The range that is being densified. This is pretty self-evident, the larger the range that $densify
    is working over, the more documents will be generated. This includes large ranges specified
    explicitly in the bounds option, and implicitly large ranges when densifying over collections
    where the minimum and maximum documents are farther from each other in the
    `bounds: "full"|"partition"` cases.

  - The step size. Smaller steps produce more documents when the range is held constant.

  - The cardinality of the fields specified in the `partitionByFields`, if set. One document
    will be generated with every value within the range for each partition, so the higher the
    cardinality, the more documents that will be generated. Specifying a `partitionByFields` will
    never decrease the number of documents generated, holding all other options equal.

GlobalDefaults:
  dbname: &db test
  MaxPhases: &MaxPhases 20
  batchSize: &batchSize 30000
  fieldName: &field "milliseconds"
  unitName: &unit "millisecond"
  index: &index
    keys: {milliseconds: 1}
    options: {name: "millisecond"}
  smallStepSize: &smallStep 3
  largeStepSize: &largeStep 8
  explicitBounds: &bounds [
    {^RandomDate: {min: "2021-01-01T00:00:02.000Z", max: "2021-01-01T00:00:10.000Z"}},
    {^RandomDate: {min: "2021-01-01T00:00:10.000Z", max: "2021-01-01T00:00:20.000Z"}}
  ]
  nop: &Nop {Nop: true}

Actors:
- Name: InsertData
  Type: Loader
  Threads: 1
  Phases:
  - Repeat: 1
    Database: *db
    Threads: 1
    CollectionCount: 1
    DocumentCount: 10000
    BatchSize: *batchSize
    Document:
      partitionKey: {^RandomInt: {min: 1, max: 100}}
      # Test a subset of units that have different characteristics.
      number: {^RandomInt: {min: 0, max: 20000}}  # Seperate codepath for numeric DensifyValues.
      milliseconds: {^RandomDate: {min: "2021-01-01T00:00:00.000Z", max: "2021-01-01T00:00:20.000Z"}}  # Most basic date unit.
      hours: {^RandomDate: {min: "2021-01-01", max: "2023-01-01"}}  # Date unit with constant number of milliseconds.
      months: {^RandomDate: {min: "2021-01-01", max: "4000-01-01"}}  # Date unit with non-constant number of milliseconds.
    # $densify stages always add a $sort on the field that is being densified, so this phase adds
    # indexes on the date/number fields so that we aren't performing an in-memory sort.
    Indexes:
    - *index
  - *Nop
  - *Nop

- Name: Quiesce
  Type: QuiesceActor
  Threads: 1
  Database: *db
  Phases:
  - *Nop
  - Repeat: 1
  - *Nop

- Name: DensifyMilliseconds
  Type: RunCommand
  Threads: 1
  Phases:
  - *Nop
  - *Nop
  - Repeat: 10
    Database: *db
    Operations:
    - OperationMetricsName: FullSmallStep
      OperationName: RunCommand
      OperationCommand:
        aggregate: Collection0
        pipeline: [{
          $densify: {
            field: *field,
            range: {
              bounds: "full",
              step: *smallStep,
              unit: *unit
            }
          }
        }]
        cursor: {batchSize: *batchSize}
    - OperationMetricsName: FullLargeStep
      OperationName: RunCommand
      OperationCommand:
        aggregate: Collection0
        pipeline: [{
          $densify: {
            field: *field,
            range: {
              bounds: "full",
              step: *largeStep,
              unit: *unit
            }
          }
        }]
        cursor: {batchSize: *batchSize}
    - OperationMetricsName: FullByPartitionSmallStep
      OperationName: RunCommand
      OperationCommand:
        aggregate: Collection0
        pipeline: [{
          $densify: {
            field: *field,
            partitionByFields: ["partitionKey"],
            range: {
              bounds: "full",
              step: *smallStep,
              unit: *unit
            }
          }
        }]
        cursor: {batchSize: *batchSize}
    - OperationMetricsName: FullByPartitionLargeStep
      OperationName: RunCommand
      OperationCommand:
        aggregate: Collection0
        pipeline: [{
          $densify: {
            field: *field,
            partitionByFields: ["partitionKey"],
            range: {
              bounds: "full",
              step: *largeStep,
              unit: *unit
            }
          }
        }]
        cursor: {batchSize: *batchSize}
    - OperationMetricsName: PartitionedByPartitionSmallStep
      OperationName: RunCommand
      OperationCommand:
        aggregate: Collection0
        pipeline: [{
          $densify: {
            field: *field,
            partitionByFields: ["partitionKey"],
            range: {
              bounds: "partition",
              unit: *unit,
              step: *smallStep
            }
          }
        }]
        cursor: {batchSize: *batchSize}
    - OperationMetricsName: PartitionedByPartitionLargeStep
      OperationName: RunCommand
      OperationCommand:
        aggregate: Collection0
        pipeline: [{
          $densify: {
            field: *field,
            partitionByFields: ["partitionKey"],
            range: {
              bounds: "partition",
              unit: *unit,
              step: *largeStep
            }
          }
        }]
        cursor: {batchSize: *batchSize}
    - OperationMetricsName: ExplicitRangeSmallStep
      OperationName: RunCommand
      OperationCommand:
        aggregate: Collection0
        pipeline: [{
          $densify: {
            field: *field,
            range: {
              step: *smallStep,
              unit: *unit,
              bounds: *bounds
            }
          }
        }]
        cursor: {batchSize: *batchSize}
    - OperationMetricsName: ExplicitRangeLargeStep
      OperationName: RunCommand
      OperationCommand:
        aggregate: Collection0
        pipeline: [{
          $densify: {
            field: *field,
            range: {
              step: *largeStep,
              unit: *unit,
              bounds: *bounds
            }
          }
        }]
        cursor: {batchSize: *batchSize}
    - OperationMetricsName: ExplicitRangeByPartitionSmallStep
      OperationName: RunCommand
      OperationCommand:
        aggregate: Collection0
        pipeline: [{
          $densify: {
            field: *field,
            partitionByFields: ["partitionKey"],
            range: {
              step: *smallStep,
              unit: *unit,
              bounds: *bounds
            }
          }
        }]
        cursor: {batchSize: *batchSize}
    - OperationMetricsName: ExplicitRangeByPartitionLargeStep
      OperationName: RunCommand
      OperationCommand:
        aggregate: Collection0
        pipeline: [{
          $densify: {
            field: *field,
            partitionByFields: ["partitionKey"],
            range: {
              step: *largeStep,
              unit: *unit,
              bounds: *bounds
            }
          }
        }]
        cursor: {batchSize: *batchSize}

AutoRun:
- When:
    mongodb_setup:
      $eq:
      - replica
      - replica-all-feature-flags
    branch_name:
      $neq:
      - v4.0
      - v4.2
      - v4.4
      - v5.0
