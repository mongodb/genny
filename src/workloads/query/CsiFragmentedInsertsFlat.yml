SchemaVersion: 2018-07-01
Owner: "@mongodb/query-execution"
Description: |
  This workload compares performance of inserts into a collection with only the default _id index,
  and in presence of either columnstore or wildcard indexes. It uses an artificial data set with
  a wide overall schema and narrow individual objects to model fragmented access to CSI, which
  clusters entries by path.
  The data size is relatively small (1e6 documents yield ~175MB data size and ~105MB storage size).
  We would like to be able to correlate the results of this workload with the similar one that uses
  nested data (CsiFragmentedInsertsNested.yml). Please make sure to update both when making changes.

Keywords:
- columnstore
- wildcard
- insert

AutoRun:
- When:
    mongodb_setup:
      $eq:
      - standalone-all-feature-flags
    branch_name:
      $neq:
      - v4.0
      - v4.2
      - v4.4
      - v5.0
      - v6.0

Clients:
  Default:
    QueryOptions:
      # Allow for longer duration since index builds may take a while.
      socketTimeoutMS: 600_000  # = 10 min
      connectTimeoutMS: 600_000

GlobalDefaults:
  MaxPhases: &maxPhases 26
  Database: &db csiFragmentedInsertsFlat

  # The Loader actor creates collections named "Collection<N>" where N corresponds to the thread's
  # number. We'll use a single collection, created by a single thread, so it becomes 'Collection0'.
  Collection: &coll Collection0

  # If modifying any of the these parameters, please review 'CsiFragmentedInsertsNested.yml' to
  # ensure that the results of these two workloads can still be correlated.
  DocumentCount: &docCount 1e6
  SchemaWidth: &schemaWidth 10000
  ObjectWidth: &objectWidth 10
  SampleSize: &sampleSize 10

ActorTemplates:
- TemplateName: InsertFromSample
  Config:
    Name: {^Parameter: {Name: "Name", Default: "Insert"}}
    Type: SamplingLoader
    Threads: {^Parameter: {Name: "Threads", Default: 1}}
    Phases:
      OnlyActiveInPhases:
        Active: [{^Parameter: {Name: "OnlyActiveInPhase", Default: 1024}}]
        NopInPhasesUpTo: *maxPhases
        PhaseConfig:
          Database: *db
          Collection: *coll

          # No more than sampleSize*objectWidth paths can be "touched" by a sample.
          SampleSize: *sampleSize

          # When the batch size is the same as sample size, each sampled document will be used in
          # the batch exactly once, and this will be repeated for the number of batches. We expect,
          # that the first batch might be affected by "cold" caches but the subsequent batches
          # would be fully warmed up.
          InsertBatchSize: *sampleSize

          # The 'SamplingLoader' actor re-samples on repeat, meaning that it would get a new set of
          # documents likely with different paths and values. This makes each repeat hit different
          # parts of the indexes, causing a long warm up tail. The instances of this template must
          # provide a valid "Repeats" value as using the default of -1 is UB.
          Repeat: {^Parameter: {Name: "Repeats", Default: -1}}

          # The instances of the template must specify the number of batches to make it clear what
          # they are testing wrt to cold/warm state. Using the default of -1 is UB.
          # The stats per batch are available in 'IndividualBulkInsert' measurement.
          Batches: {^Parameter: {Name: "Batches", Default: -1}}

Actors:
# This workload is completely linear with one actor per phase. Having phases when nothing happens
# is mildly wastful, but I'm tired of having to adjust the numbers, so assuming "sparse" numbering
# scheme that is more stable.
# Phases:
# 0 setup (no index), 10 create CSI, 20 replace CSI with wildcard index
# 1,                  11,            21                                  - quiese
# 3,                  13,            23                                  - insert tail
# 4,                  14,            24                                  - insert warm

- Name: Loader
  Type: Loader
  Threads: 1
  Phases:
    OnlyActiveInPhases:
      Active: [0]
      NopInPhasesUpTo: *maxPhases
      PhaseConfig:
        # Cannot have more threads than the actor itself.
        Threads: 1
        Repeat: 1
        Database: *db
        CollectionCount: 1
        DocumentCount: *docCount
        BatchSize: 1000
        Document:
          # This loader will populate the collection with documents that look like:
          # {
          #   _id: ObjectId(...),
          #   root: {
          #     x271: NumberInt(9917),
          #     x6305: NumberInt(11),
          #     x8: NumberInt(1022),
          #     <7 more fields like this>
          #   }
          # }
          root: {^Object: {
            withNEntries: *objectWidth,

            # Do we want to use a non-uniform distribution for the fiedls, modelling that some are
            # rarer than others? The sampling might become unstable in this case and even harder to
            # interpret the results.
            havingKeys: {^FormatString: {
              "format": "x%d",
              "withArgs": [{^RandomInt: {min: 0, max: *schemaWidth}}]
            }},

            # We would like to compare CSI to wildcard indexes and to model similarly fragmented
            # access to the index, we are using uniform value distribution here.
            andValues: {^RandomInt: {min: 0, max: *schemaWidth}},

            # Occasionally, the key generator might produce the same key name. For this workload,
            # it's OK to have some of the objects with fewer than 'objectWidth' fields (and we don't
            # want to test parsing of the duplicated keys for the index as it's not a common user
            # scenario).
            duplicatedKeys: skip
          }}

- Name: Quiese
  Type: QuiesceActor
  Threads: 1
  Database: *db
  Phases:
    OnlyActiveInPhases:
      Active: [1, 11, 21]
      NopInPhasesUpTo: *maxPhases
      PhaseConfig:
        Repeat: 1

# Do a bunch of inserts with re-sampling, we expect a long warm-up tail in this test but not too
# long (P50 and P80 for latency should be close).
# Target measurements: Latency50thPercentile
- ActorFromTemplate:
    TemplateName: InsertFromSample
    TemplateParameters:
      Name: NoIndexes_tail
      OnlyActiveInPhase: 3
      Repeats: 200  # with sample size of 10, this "touches" 200*10*10 paths > schemaWidth
      Batches: 1

# Now do multiple inserts of documents with the same schema. The performance of the first insert
# might be affected by the inserts in the previous stages, but it should stabilize after that so, by
# using a large number of batches, it should ammortize sufficiently to have P90 simialr to P50 for
# the latency.
# Target measurements: Latency90thPercentile
- ActorFromTemplate:
    TemplateName: InsertFromSample
    TemplateParameters:
      Name: NoIndexes_warm
      OnlyActiveInPhase: 4
      Repeats: 1
      Batches: 200

- Name: BuildColumnStoreIndex
  Type: RunCommand
  Threads: 1
  Phases:
    OnlyActiveInPhases:
      Active: [10]
      NopInPhasesUpTo: *maxPhases
      PhaseConfig:
        Repeat: 1
        Database: *db
        Operations:
        - OperationMetricsName: BulkBuildColumnStoreIndex
          OperationName: RunCommand
          OperationCommand:
            createIndexes: *coll
            indexes:
            - key: {"$**": "columnstore"}
              name: csi

# Repeat the same tests as with no index in presence of CSI. We are instantiating new actors as we
# need to collect the same measurements with different names. The previous stages have inserted
# 200*10 + 200*10 = 4000 new documents, which is tiny compared to the 1e6 collection size.
- ActorFromTemplate:
    TemplateName: InsertFromSample
    TemplateParameters:
      Name: Csi_tail
      OnlyActiveInPhase: 13
      Repeats: 200
      Batches: 1

- ActorFromTemplate:
    TemplateName: InsertFromSample
    TemplateParameters:
      Name: Csi_warm
      OnlyActiveInPhase: 14
      Repeats: 1
      Batches: 200

- Name: ReplaceCsiWithWildcardIndex
  Type: RunCommand
  Threads: 1
  Phases:
    OnlyActiveInPhases:
      Active: [20]
      NopInPhasesUpTo: *maxPhases
      PhaseConfig:
        Repeat: 1
        Database: *db
        Operations:
        - OperationName: RunCommand
          OperationCommand:
            dropIndexes: *coll
            index: csi
        - OperationName: RunCommand
          OperationCommand:
            createIndexes: *coll
            indexes:
            - key: {"root.$**": 1}
              name: root

# Repeat the same tests as with no index in presence of CSI. We are instantiating new actors as we
# need to collect the same measurements with different names. The previous stages have inserted
# 2*(200*10 + 200*10) = 8000 new documents, which is still tiny compared to the 1e6
# collection size.
- ActorFromTemplate:
    TemplateName: InsertFromSample
    TemplateParameters:
      Name: Wildcard_tail
      OnlyActiveInPhase: 23
      Repeats: 200
      Batches: 1

- ActorFromTemplate:
    TemplateName: InsertFromSample
    TemplateParameters:
      Name: Wildcard_warm
      OnlyActiveInPhase: 24
      Repeats: 1
      Batches: 200

