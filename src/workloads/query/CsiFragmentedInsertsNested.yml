SchemaVersion: 2018-07-01
Owner: "@mongodb/query-execution"
Description: |
  This workload compares performance of inserts into a collection with only the default _id index
  and in presence of a full columnstore index. We are not comparing to wildcard because the nested
  data makes creating of a wildcard index too slow. Before changing any of the parameters in this
  workload please make sure the results can be correlated with 'CsiFragmentedInsertsFlat.yml'.

Keywords:
- columnstore
- insert

AutoRun:
- When:
    mongodb_setup:
      $eq:
      - standalone-all-feature-flags
    branch_name:
      $neq:
      - v4.0
      - v4.2
      - v4.4
      - v5.0
      - v6.0

Clients:
  Default:
    QueryOptions:
      # Allow for longer duration since index builds may take a while.
      socketTimeoutMS: 600_000  # = 10 min
      connectTimeoutMS: 600_000

GlobalDefaults:
  MaxPhases: &maxPhases 10
  Database: &db csiFragmentedInsertsNested
  # The Loader actor creates collections named "Collection<N>" where N corresponds to the thread's
  # number. We'll use a single collection, created by a single thread, so it becomes 'Collection0'.
  Collection: &coll Collection0
  # If modifying any of the these parameters, please review 'CsiFragmentedInsertsFlat.yml' to
  # ensure that the results of these two workloads can still be correlated.
  DocumentCount: &docCount 1e6
  SchemaWidth: &schemaWidth 10000
  ObjectWidth: &objectWidth 5  # with two nested paths, get 10 paths_per_object
  SampleSize: &sampleSize 100  # want: sampleSize * paths_per_object ~ 0.1 * schemaWidth

ActorTemplates:
- TemplateName: InsertFromSample
  Config:
    Name: {^Parameter: {Name: "Name", Default: "Insert"}}
    Type: SamplingLoader
    Threads: {^Parameter: {Name: "Threads", Default: 1}}
    Phases:
      OnlyActiveInPhases:
        Active: [{^Parameter: {Name: "OnlyActiveInPhase", Default: 1024}}]
        NopInPhasesUpTo: *maxPhases
        PhaseConfig:
          Database: *db
          Collection: *coll
          # The 'SamplingLoader' actor re-samples on repeat, meaning that it would get a new set of
          # documents likely with different paths. This makes each repeat hit different parts of the
          # index, causing a long warm up tail.
          Repeat: 1
          # Sample size of 100 means that no more than 100*objectWidth = 1000 paths will be
          # "touched" by the sample, which is about 10% of all paths (aka schemaWidth).
          SampleSize: *sampleSize
          # When the batch size is the same as sample size, each sampled document will be used in
          # the batch exactly once, and this will be repeated for the number of batches. We expect,
          # that the first batch would exhibit "cold" cache behaviour and the subsequent batches
          # would be fully warmed up.
          InsertBatchSize: *sampleSize
          # The instances of the template should explicitly specify the number of batches to make it
          # clear what they are testing wrt to cold/warm scenario. Using the default of 0 is UB.
          # The stats per batch are available in 'IndividualBulkInsert' measurement.
          Batches: {^Parameter: {Name: "Batches", Default: 0}}

- TemplateName: SettleDown
  Config:
    # We are not interested in measuring the quiese phases, so it's OK to use the same name for all
    # of them.
    Name: Quiese
    Type: QuiesceActor
    Threads: 1
    Database: *db
    Phases:
      OnlyActiveInPhases:
        Active: [{^Parameter: {Name: "OnlyActiveInPhase", Default: 1024}}]
        NopInPhasesUpTo: *maxPhases
        PhaseConfig:
          Repeat: 1

Actors:
- Name: Setup
  Type: AdminCommand
  Threads: 1
  Phases:
    OnlyActiveInPhases:
      Active: [0]
      NopInPhasesUpTo: *maxPhases
      PhaseConfig:
        Repeat: 1
        Thread: 1
        Database: admin
        Operations:
        - OperationName: AdminCommand
          OperationCommand:
            setParameter: 1
            internalQueryFrameworkControl: "trySbeEngine"

- Name: Loader
  Type: Loader
  Threads: 1
  Phases:
    OnlyActiveInPhases:
      Active: [1]
      NopInPhasesUpTo: *maxPhases
      PhaseConfig:
        # Cannot have more threads than the actor itself.
        Threads: 1
        Repeat: 1
        Database: *db
        CollectionCount: 1
        DocumentCount: *docCount
        BatchSize: 1000
        Document:
          # Generate documents that would produce non-trivial array info strings. When these docs
          # are inserted, we want them to affect about 10 separated locations in the index, which is
          # achieved by uniform distribution of xN fields and because for each xN both "a" and "b"
          # subpaths are likely to be generated.
          # The documents will looks like:
          # {
          #   _id: ObjectId("63890d0df7b608a2d303b941"),
          #   root: [
          #     {
          #       x8372 : [{a: [42, *]}, {b: {obj: *}}, {a: [42, *], b: [42, *]}, {b: *}, {b: *}],
          #       <4 more xN fields>
          #     }
          #   ]
          # }
          root: {^Array: {
            of: {^Object: {
              withNEntries: *objectWidth,
              havingKeys: {^FormatString: {
                "format": "x%d", "withArgs": [{^RandomInt: {min: 0, max: *schemaWidth}}]
              }},
              andValues: {^Array: {
                of:
                  # Create an object with either "a" or "b" key, or both. This is achieved by using
                  # 'duplicatedKeys: skip' parameter, which would ignore the second generated key if
                  # it has the same name as the first, so with probability 1/2 we'll get both fields
                  # and with probability 1/4 each of {a: } and {b: }.
                  {^Object: {
                    withNEntries: 2,
                    havingKeys: {^RandomString: {length: 1, alphabet: ab}},
                    andValues: {^Choose: {from: [
                      {^RandomInt: {min: 0, max: *schemaWidth}},
                      [42, {^RandomInt: {min: 0, max: *schemaWidth}}],
                      {obj: {^RandomInt: {min: 0, max: *schemaWidth}}}
                    ]}},
                    duplicatedKeys: skip
                  }},
                # 5 elements make it almost certain that both "a" and "b" are used in the array to
                # yield ~10 paths per object.
                number: 5
              }},
              duplicatedKeys: skip
            }},
            number: 1
          }}

# Isolate the perf data for a cold insert in absence of indexes.
- ActorFromTemplate:
    TemplateName: SettleDown
    TemplateParameters:
      OnlyActiveInPhase: 2

- ActorFromTemplate:
    TemplateName: InsertFromSample
    TemplateParameters:
      Name: Insert_no_indexes_cold
      OnlyActiveInPhase: 3
      Batches: 1

# Resampling might affect the caches made by the insert above. To start from the same point, settle
# again. The first batch is expected to have similar pert to the cold insert above, and the later
# batches to be stabely warm.
- ActorFromTemplate:
    TemplateName: SettleDown
    TemplateParameters:
      OnlyActiveInPhase: 4

- ActorFromTemplate:
    TemplateName: InsertFromSample
    TemplateParameters:
      Name: Insert_no_indexes_warm
      OnlyActiveInPhase: 5
      Batches: 10

- Name: BuildColumnStoreIndex
  Type: RunCommand
  Threads: 1
  Phases:
    OnlyActiveInPhases:
      Active: [6]
      NopInPhasesUpTo: *maxPhases
      PhaseConfig:
        Repeat: 1
        Database: *db
        Operations:
        - OperationMetricsName: BulkBuildColumnStoreIndex
          OperationName: RunCommand
          OperationCommand:
            createIndexes: *coll
            indexes:
            - key: {"$**": "columnstore"}
              name: csi

# Isolate the perf data for a cold insert in presence of a columnstore index.
- ActorFromTemplate:
    TemplateName: SettleDown
    TemplateParameters:
      OnlyActiveInPhase: 7

- ActorFromTemplate:
    TemplateName: InsertFromSample
    TemplateParameters:
      Name: Insert_csi_cold
      OnlyActiveInPhase: 8
      Batches: 1

# We expect the first batch of 10 to have the same perf charteristics as the cold insert above, the
# following batches should be warm both in the rowstore and in the index because the same paths are
# reused (from the single sample).
- ActorFromTemplate:
    TemplateName: SettleDown
    TemplateParameters:
      OnlyActiveInPhase: 9

- ActorFromTemplate:
    TemplateName: InsertFromSample
    TemplateParameters:
      Name: Insert_csi_warm
      OnlyActiveInPhase: 10
      Batches: 10


