SchemaVersion: 2018-07-01
Owner: "@mongodb/query"
Description: >
  This is a template of helpers for the QueryStats workload.

GlobalDefaults:
  PhasesPerStage: &PhasesPerStage 6
  StagesPerGroup: &StagesPerGroup 3
  SetupPhases: &SetupPhases 2

  Database: &Database {^Parameter: {Name: Database, Default: test}}
  Collection: &Collection {^Parameter: {Name: Collection, Default: Collection0}}
  NumGroups: &NumGroups {^Parameter: {Name: NumGroups, Default: {unused: "Please specify the number of \"groups\" being run."}}}
  NumStages: &NumStages {^Parameter: {Name: NumStages, Default: {^NumExpr: {withExpression: "groups * spg", andValues: {groups: *NumGroups, spg: *StagesPerGroup}}}}}
  Stage: &Stage {^Parameter: {Name: Stage, Default: {unused: "Please specify the stage."}}}
  StageToPhase: &StageToPhase {^NumExpr: {withExpression: "(stage - 1) * pps + setup", andValues: {stage: *Stage, pps: *PhasesPerStage, setup: *SetupPhases}}}
  MaxPhases: &MaxPhases {^NumExpr: {withExpression: "stages * pps + setup", andValues: {stages: *NumStages, pps: *PhasesPerStage, setup: *SetupPhases}}}

  QueryStatsCacheSizeMB: &QueryStatsCacheSizeMB {^Parameter: {Name: QueryStatsCacheSizeMB, Default: 300}}
  QueryStatsCacheSize: &QueryStatsCacheSize {^PreprocessorFormatString: {format: "%dMB", withArgs: [*QueryStatsCacheSizeMB]}}
  PrepopulateMB: &PrepopulateMB {^NumExpr: {withExpression: "ratio * cacheSize", andValues: {ratio: {^Parameter: {Name: PrepopulateRatio, Default: 0}}, cacheSize: *QueryStatsCacheSizeMB}}}
  QueryStatsSuffix: &QueryStatsSuffix {^Parameter: {Name: Suffix, Default: ""}}
  EntriesPerObjectName: &EntriesPerObjectName {^Parameter: {Name: EntriesPerObjectName, Default: {unused: "Need to provide a name for this entries/object variant."}}}

  BinDataSensitive: &BinDataSensitive {^BinDataSensitive: {numBytes: 32}}

SetupStage:
- Name: ClearCollection
  Type: CrudActor
  Database: *Database
  Threads: 1
  Phases:
    OnlyActiveInPhases:
      Active: [0]
      NopInPhasesUpTo: *MaxPhases
      PhaseConfig:
        Repeat: 1
        Threads: 1
        Collection: *Collection
        Operations:
        - OperationName: drop

- Name: InsertData
  Type: Loader
  Threads: 4
  Phases:
    OnlyActiveInPhases:
      Active: [1]
      NopInPhasesUpTo: *MaxPhases
      PhaseConfig:
        Repeat: 1
        Database: *Database
        MultipleThreadsPerCollection: true
        CollectionCount: 1
        DocumentCount: {^Parameter: {Name: DocumentCount, Default: {unused: "Need to pass in a document count."}}}
        BatchSize: 1000
        Document:
          a1: &integer {^RandomInt: {min: -100, max: 100}}
          a2: *integer
          string: &string {^RandomString: {length: 5}}
        Indexes:
          - keys: {a1: 1, a2: 1}

QueryStatsStage:
- Name: {^PreprocessorFormatString: {format: "ClearQueryStats%s", withArgs: [*QueryStatsSuffix]}}
  Type: RunCommand
  Threads: 1
  Phases:
    OnlyActiveInPhases:
      Active: [*StageToPhase]
      NopInPhasesUpTo: *MaxPhases
      PhaseConfig:
        Repeat: 1
        Database: admin
        Operations:
        - OperationName: AdminCommand
          OperationCommand:
            # Configuring the queryStats store size to an arbitrary value which seems reasonable.
            # This ensures that if run on different sized machines, the test will remain the same.
            setParameter: 1
            internalQueryStatsCacheSize: 0MB

- Name: {^PreprocessorFormatString: {format: "SetQueryStats%s", withArgs: [*QueryStatsSuffix]}}
  Type: RunCommand
  Threads: 1
  Phases:
    OnlyActiveInPhases:
      Active: [{^NumExpr: {withExpression: "phase + 1", andValues: {phase: *StageToPhase}}}]
      NopInPhasesUpTo: *MaxPhases
      PhaseConfig:
        Repeat: 1
        Database: admin
        Operations:
        - OperationName: AdminCommand
          OperationCommand:
            # Configuring the queryStats store size to an arbitrary value which seems reasonable.
            # This ensures that if run on different sized machines, the test will remain the same.
            setParameter: 1
            internalQueryStatsCacheSize: *QueryStatsCacheSize

- Name: {^PreprocessorFormatString: {format: "SetupQuiesce%s", withArgs: [*QueryStatsSuffix]}}
  Type: QuiesceActor
  Threads: 1
  Database: *Database
  Phases:
    OnlyActiveInPhases:
      Active: [{^NumExpr: {withExpression: "phase + 2", andValues: {phase: *StageToPhase}}}]
      NopInPhasesUpTo: *MaxPhases
      PhaseConfig:
        Repeat: 1

- Name: {^PreprocessorFormatString: {format: "Prepopulate%s", withArgs: [*QueryStatsSuffix]}}
  Type: CrudActor
  Threads: 32
  Database: *Database
  Phases:
    OnlyActiveInPhases:
      Active: [{^NumExpr: {withExpression: "phase + 3", andValues: {phase: *StageToPhase, pps: *PhasesPerStage}}}]
      NopInPhasesUpTo: *MaxPhases
      PhaseConfig:
        Repeat: {^NumExpr: {withExpression: "targetMB * 100", andValues: {targetMB: *PrepopulateMB}}}
        #Repeat: 1000
        Collection: *Collection
        Operations:
          ^FlattenOnce:
          - &PrepopulateOp OperationName: find
            OperationCommand:
              # This will send a find command that is a little over 320B per query shape key.
              Filter:
                $and:
                # So that this can use an index scan and immediately return. We don't want to be
                # spending actual time on this query, we just want it in the logs.
                - a1: {^RandomDouble: {min: 1000000, max: 10000000000}}
                - ^Object:
                    withNEntries: 10
                    havingKeys: 
                      ^FormatString:
                        format: "%32d"
                        withArgs: [{^Inc: {start: 0, multiplier: 1, step: 32}}]
                    andValues: {$exists: true}
                    duplicatedKeys: skip

- Name: {^PreprocessorFormatString: {format: "PrepopulateQuiesce%s", withArgs: [*QueryStatsSuffix]}}
  Type: QuiesceActor
  Threads: 1
  Database: *Database
  Phases:
    OnlyActiveInPhases:
      Active: [{^NumExpr: {withExpression: "phase + 4", andValues: {phase: *StageToPhase}}}]
      NopInPhasesUpTo: *MaxPhases
      PhaseConfig:
        Repeat: 1

- Name: {^PreprocessorFormatString: {format: "FindCommand%s", withArgs: [*QueryStatsSuffix]}}
  Type: CrudActor
  Threads: 32
  Database: *Database
  Phases:
    OnlyActiveInPhases:
      Active: [{^NumExpr: {withExpression: "phase + pps - 1", andValues: {phase: *StageToPhase, pps: *PhasesPerStage}}}]
      NopInPhasesUpTo: *MaxPhases
      PhaseConfig:
        Duration: 5 minutes
        Collection: *Collection
        Operations:
        - OperationName: find
          OperationCommand:
            # This will create a find command with a random number of fields from 3 to 350, to create varying query shapes and sizes.
            Filter:
              {$and:
                [{a1: 1}, {a2: 1}, {^Cycle: {ofLength: 25, fromGenerator: {^Object: {
                  withNEntries: {^Parameter: {Name: EntriesPerObject, Default: {unused: "Need to provide the number of entries per object."}}},
                  havingKeys: {^RandomString: {length: 10}},
                  andValues: {$exists: false},
                  duplicatedKeys: skip
                }}}}]
              }
- Name: {^PreprocessorFormatString: {format: "QueryStatsAggregation%s", withArgs: [*QueryStatsSuffix]}}
  Type: AdminCommand
  Threads: 1
  Phases:
    OnlyActiveInPhases:
      Active: {^Parameter: {Name: QueryStatsActive, Default: [{^NumExpr: {withExpression: "phase + pps - 1", andValues: {phase: *StageToPhase, pps: *PhasesPerStage}}}]}}
      NopInPhasesUpTo: *MaxPhases
      PhaseConfig:
        Duration: 5 minutes
        SleepBefore: 5 seconds
        Database: admin
        Operations:
        - OperationMetricsName: QueryStatsMetrics
          OperationName: AdminCommand
          OperationCommand:
            aggregate: 1
            pipeline:
            - $queryStats: {^Parameter: {Name: "QueryStatsParameters", Default: {}}}
              # The purpose of $count is to ensure we've exhausted the cursor/ data stream and looked at each partition.
            - $count: "numDocuments"
            cursor: {}

QueryStatsGroup:
  ^FlattenOnce:
    # Find without QueryStats.
    - LoadConfig:
        Path: QueryStats.tmpl
        Key: QueryStatsStage
        Parameters:
          Database: *Database
          Collection: *Collection
          NumStages: *NumStages
          Stage: {^NumExpr: {withExpression: "3 * (group - 1) + 1", andValues: {group: &Group {^Parameter: {Name: Group, Default: {unused: "Need to specify a group number."}}}}}}
          Suffix: {^PreprocessorFormatString: {format: "Base%sEntries%dMbCache%dMbPrepop", withArgs: [*EntriesPerObjectName, *QueryStatsCacheSizeMB, *PrepopulateMB]}}
          QueryStatsActive: []
          QueryStatsParameters: {}

    # QueryStats with HMAC.
    - LoadConfig:
        Path: QueryStats.tmpl
        Key: QueryStatsStage
        Parameters:
          Database: *Database
          Collection: *Collection
          NumStages: *NumStages
          Stage: {^NumExpr: {withExpression: "3 * (group - 1) + 2", andValues: {group: *Group}}}
          Suffix: {^PreprocessorFormatString: {format: "WithHMAC%sEntries%dMbCache%dMbPrepop", withArgs: [*EntriesPerObjectName, *QueryStatsCacheSizeMB, *PrepopulateMB]}}
          QueryStatsParameters: {transformIdentifiers: {algorithm: "hmac-sha-256", hmacKey: *BinDataSensitive}}

    # QueryStats without HMAC.
    - LoadConfig:
        Path: QueryStats.tmpl
        Key: QueryStatsStage
        Parameters:
          Database: *Database
          Collection: *Collection
          NumStages: *NumStages
          Stage: {^NumExpr: {withExpression: "3 * (group - 1) + 3", andValues: {group: *Group}}}
          Suffix: {^PreprocessorFormatString: {format: "WithoutHMAC%sEntries%dMbCache%dMbPrepop", withArgs: [*EntriesPerObjectName, *QueryStatsCacheSizeMB, *PrepopulateMB]}}
          QueryStatsParameters: {}
