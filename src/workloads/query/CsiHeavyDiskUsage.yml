SchemaVersion: 2018-07-01
Owner: "@mongodb/query-execution"
Description: |
  This workload measures bulk insert performance against a collection named "products" in a database
  named "bestbuy". The collection and database must be set up before running the workload. The
  workload itself has no expectation as far as the size or schema of the data are concerned but it's
  only useful when run against larger datasets to actually generate heavy disk IO.

  The purpose of this workload is to compare the insert performance with columnar indexes to inserts
  without them. To get a better illustration, it measures insert performance in three scenarios:
   - "Default" indexes present - a set of indexes that are typically present on the target dataset,
     those that would be useful for the typical query workloads.
   - No indexes present.
   - Only a column store index. A column store index isn't expected to realistically replace all of
     those indexes in production, but it could replace some and knowing it's relative performance
     cost could help make that decision.

  The workload consists of the following phases and actors:
   - Measure bulk inserting with the default indexes (SamplingLoader)
   - Drop all non-_id indexes (RunCommand Actor)
   - Measure bulk inserting again (SamplingLoader)
   - Build the column store index (RunCommand Actor)
   - Measure bulk inserting again (SamplingLoader)

Keywords:
- columnstore
- analytics
- scale
- insert

Clients:
  Default:
    QueryOptions:
      # Allow for longer duration since index builds may take a while.
      socketTimeoutMS: 3_600_000  # = 1 hour
      connectTimeoutMS: 3_600_000

GlobalDefaults:
  # The expected database and collection names.
  Database: &db heavy_io
  Collection: &coll coll

  LoadThreads: &loadThreads 8
  SampleSize: &sampleSize 1000
  Batches: &batches 50 # Per Thread

  ColumnStoreIndexSpec: &ColumnStoreIndexSpec
    key: {$**: "columnstore"}
    name: "columnstore"

  WildcardIndexSpec: &WildcardIndexSpec
    key: {$**: 1}
    name: "wildcard"

  MaxPhases: &maxPhases 30

  SamplingLoaderPhaseConfig: &SamplingLoaderPhaseConfig
    Database: *db
    Collection: *coll
    Repeat: 1
    InsertBatchSize: 1000
    Batches: 50 # Per Thread

ActorTemplates:
# We want to be able to compare results from the same test between the runs in presence of different
# indexes. For this we'll have to instantiate the same actor multiple times with a unique name.
- TemplateName: InsertFromSample
  Config:
    Name: {^Parameter: {Name: "Name", Default: "Insert"}}
    Type: SamplingLoader
    Database: *db
    Collection: *coll
    SampleSize: *sampleSize
    Pipeline: [{$set: {genny_added: true}}]
    Threads: *loadThreads
    Phases:
      OnlyActiveInPhases:
        Active: [{^Parameter: {Name: "OnlyActiveInPhase", Default: 1024}}] # do not run by default
        NopInPhasesUpTo: *maxPhases
        PhaseConfig:
          InsertBatchSize: *sampleSize
          Repeat: 1
          Batches: *batches

# Phases:
# Quiesce  Insert  Delete  UpdateIndexes
#   0        1       2       9
#   10       11      12      19
#   20       21
Actors:
- Name: Quiesce
  Type: QuiesceActor
  Threads: 1
  Database: *db
  Phases:
    OnlyActiveInPhases:
      Active: [0, 10, 20]
      NopInPhasesUpTo: *maxPhases
      PhaseConfig:
        Repeat: 1

# The insert tests add 1000*50*8 = 400,000 records, which might be significant comparing to the
# collection size, so let's remove the inserted records before running the next test.
- Name: DeleteInserted
  Type: CrudActor
  Database: *db
  Phases:
    OnlyActiveInPhases:
      Active: [2, 12] # don't delete after wildcard test, because it's the last test
      NopInPhasesUpTo: *maxPhases
      PhaseConfig:
        Repeat: 1
        MetricsName: ignore
        Database: *db
        Collection: *coll
        Operations:
        - OperationName: bulkWrite
          OperationCommand:
            WriteOperations:
            - WriteCommand: deleteMany
              Filter:
                {genny_added: true}

- ActorFromTemplate:
    TemplateName: InsertFromSample
    TemplateParameters:
      Name: DefaultIndexes
      OnlyActiveInPhase: 1

- Name: SwitchToCSI
  Type: RunCommand
  Threads: 1
  Phases:
    OnlyActiveInPhases:
      Active: [9]
      NopInPhasesUpTo: *maxPhases
      PhaseConfig:
        Repeat: 1
        Database: *db
        Operations:
        - OperationName: RunCommand
          OperationCommand:
            dropIndexes: *coll
            # This will drop all non-essential indexes (_id and any shard key index remain)
            index: '*'
        - OperationName: RunCommand
          OperationCommand:
            createIndexes: *coll
            indexes:
            - *ColumnStoreIndexSpec

- ActorFromTemplate:
    TemplateName: InsertFromSample
    TemplateParameters:
      Name: Csi
      OnlyActiveInPhase: 11

- Name: SwitchToWildcard
  Type: RunCommand
  Threads: 1
  Phases:
    OnlyActiveInPhases:
      Active: [19]
      NopInPhasesUpTo: *maxPhases
      PhaseConfig:
        Repeat: 1
        Database: *db
        Operations:
        - OperationName: RunCommand
          OperationCommand:
            dropIndexes: *coll
            # This will drop all non-essential indexes (_id and any shard key index remain)
            index: '*'
        - OperationName: RunCommand
          OperationCommand:
            createIndexes: *coll
            indexes:
            - *WildcardIndexSpec

- ActorFromTemplate:
    TemplateName: InsertFromSample
    TemplateParameters:
      Name: Wildcard
      OnlyActiveInPhase: 21

# TODO PERF-3094: Revive 'AutoRun' configuration when the project is near to a closure.
# AutoRun:
# - When:
#     mongodb_setup:
#       $eq:
#       - standalone-all-feature-flags
#     branch_name:
#       $neq:
#       - v4.0
#       - v4.2
#       - v4.4
#       - v5.0
#       - v5.3
#       - v6.0
#     ThenRun:
#     - test_control: bestbuy_inserts
