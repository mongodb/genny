// Copyright 2019-present MongoDB Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef HEADER_E6E05F14_BE21_4A9B_822D_FFD669CFB1B4_INCLUDED
#define HEADER_E6E05F14_BE21_4A9B_822D_FFD669CFB1B4_INCLUDED

#include <exception>
#include <memory>
#include <optional>
#include <ostream>
#include <string_view>
#include <utility>
#include <variant>
#include <vector>

#include <bsoncxx/builder/basic/array.hpp>
#include <bsoncxx/builder/basic/document.hpp>
#include <bsoncxx/builder/stream/document.hpp>
#include <bsoncxx/types.hpp>
#include <bsoncxx/view_or_value.hpp>

#include <yaml-cpp/yaml.h>

#include <value_generators/DefaultRandom.hpp>

namespace genny::value_generators {

/**
 * Throw this to indicate bad configuration.
 */
class InvalidValueGeneratorSyntax : public std::invalid_argument {
public:
    using std::invalid_argument::invalid_argument;
};


/*
 * This is the base class for all document generrators. A document generator generates a possibly
 * random bson view that can be used in generating interesting mongodb requests.
 *
 */
class DocumentGenerator {
public:
    virtual ~DocumentGenerator(){};

    /*
     * @param doc
     *  The bson stream builder used to hold state for the view. The view lifetime is tied to that
     * doc.
     *
     * @return
     *  Returns a bson view of the generated document.
     */
    virtual bsoncxx::document::view view(bsoncxx::builder::stream::document& doc) {
        return doc.view();
    };
};


/*
 * Factory function to parse a YAML Node and make a document generator of the correct type.
 *
 * @param Node
 *  The YAML node with the configuration for this document generator.
 * @param DefaultRandom
 *  A reference to the random number generator for the owning thread. Internal object may save a
 * reference to this random number generator.
 */
std::unique_ptr<DocumentGenerator> makeDoc(YAML::Node, genny::DefaultRandom&);


/**
 * A variant type for representing different kinds of values that can be generated by an Expression
 * instance.
 *
 * The bsoncxx::types::b_document and bsoncxx::types::b_array cases that are part of
 * bsoncxx::types::value do not allow for BSON documents or arrays which own their underlying buffer
 * and instead can only be constructed from their respective view types. This is incompatible with
 * Expression::evaluate() because the generated (owning) BSON document or array must outlive its
 * view. Additionally, the Value class uses the bsoncxx::document::view_or_value and
 * bsoncxx::array::view_or_value types to represent BSON documents and arrays that may optionally
 * own their underlying buffer. Allowing for view types leaves the possibility open for never
 * copying a fixed document or array value once it is parsed from the configuration file.
 *
 * Note that the Value class encapsulates std::variant rather than aliases it in order to define a
 * custom std::ostream::operator<< for it.
 */
class Value {
public:
    //
    // Constructors
    //

    explicit Value(bool value);
    explicit Value(int32_t value);
    explicit Value(int64_t value);
    explicit Value(double value);
    explicit Value(std::string value);
    explicit Value(bsoncxx::types::b_null value);
    explicit Value(bsoncxx::document::view_or_value value);
    explicit Value(bsoncxx::array::view_or_value value);

    //
    // Getters
    //

    bool getBool() const;
    int32_t getInt32() const;
    int64_t getInt64() const;
    double getDouble() const;
    std::string getString() const;
    bsoncxx::types::b_null getNull() const;
    bsoncxx::document::view_or_value getDocument() const;
    bsoncxx::array::view_or_value getArray() const;

    /**
     * Return `_value` as an int64_t if it is of type int32_t or int64_t, or std::nullopt if it is
     * some other type.
     */
    std::optional<int64_t> tryAsInt64() const;

    /**
     * Append the underlying `_value` to the document `doc` using the field name `key`.
     *
     * @warning
     *  After calling appendToBuilder() it is illegal to call any methods on this instance, unless
     *  it is subsequenly moved into.
     */
    void appendToBuilder(bsoncxx::builder::basic::document& doc, std::string key);

    /**
     * Append the underlying `_value` to the array `arr`.
     *
     * @warning
     *  After calling appendToBuilder() it is illegal to call any methods on this instance, unless
     *  it is subsequenly moved into.
     */
    void appendToBuilder(bsoncxx::builder::basic::array& arr);

private:
    using VariantType = std::variant<bool,
                                     int32_t,
                                     int64_t,
                                     double,
                                     std::string,
                                     bsoncxx::types::b_null,
                                     bsoncxx::document::view_or_value,
                                     bsoncxx::array::view_or_value>;

    friend std::ostream& operator<<(std::ostream& out, const Value& value);

    VariantType _value;
};


class Expression;
using UniqueExpression = std::unique_ptr<Expression>;


/**
 * Base class for generating values.
 *
 * Its API is modeled off the Expression class for representing aggregation expressions in the
 * MongoDB Server.
 */
class Expression {
public:
    using Parser = std::function<UniqueExpression(YAML::Node)>;

    /**
     * Parse `node` into one of the Expression types registered in the `parserMap`.
     *
     * @throws InvalidConfigurationException if `node` isn't a mapping type with a '^'-prefixed key.
     */
    static UniqueExpression parseExpression(YAML::Node node);

    /**
     * Parse `node` into either:
     *   - one of the Expression types registered in the `parserMap`, or
     *   - a DocumentExpression instance containing further nested Expression types.
     *
     * @throws InvalidConfigurationException if `node` isn't a mapping type.
     */
    static UniqueExpression parseObject(YAML::Node node);

    /**
     * Parse `node` into one of the following:
     *   - one of the Expression types registered in the `parserMap`,
     *   - a DocumentExpression instance containing further nested Expression types,
     *   - an ArrayExpression instance containing a list Expression types,
     *   - a ConstantExpression instance representing a scalar value.
     *
     * @throws InvalidConfigurationException if `node` is malformed.
     */
    static UniqueExpression parseOperand(YAML::Node node);

    virtual ~Expression() = default;

    /**
     * Generate a possibly randomized value.
     *
     * @throws InvalidConfigurationException if the arguments to this Expression evaluate an
     * unexpected type.
     */
    virtual Value evaluate(genny::DefaultRandom& rng) const = 0;
};


/**
 * Class for representing a fixed scalar value.
 */
class ConstantExpression : public Expression {
public:
    static UniqueExpression parse(YAML::Node node);

    ConstantExpression(Value value);
    Value evaluate(genny::DefaultRandom& rng) const override;

private:
    const Value _value;
};


/**
 * Class for generating a bsoncxx::document::value with its elements generated from other Expression
 * types.
 */
class DocumentExpression : public Expression {
public:
    using ElementType = std::pair<std::string, UniqueExpression>;

    static UniqueExpression parse(YAML::Node node);

    DocumentExpression(std::vector<ElementType> elements);
    Value evaluate(genny::DefaultRandom& rng) const override;

private:
    const std::vector<ElementType> _elements;
};


/**
 * Class for generating a bsoncxx::array::value with its elements generated from other Expression
 * types.
 */
class ArrayExpression : public Expression {
public:
    using ElementType = UniqueExpression;

    static UniqueExpression parse(YAML::Node node);

    ArrayExpression(std::vector<ElementType> elements);
    Value evaluate(genny::DefaultRandom& rng) const override;

private:
    const std::vector<ElementType> _elements;
};


/**
 * Base class for generating random int64_t values.
 */
class RandomIntExpression : public Expression {
public:
    static UniqueExpression parse(YAML::Node node);
};


/**
 * Class for generating random int64_t values according to a uniform distribution.
 *
 * See std::uniform_int_distribution for more details.
 */
class UniformIntExpression : public RandomIntExpression {
public:
    UniformIntExpression(UniqueExpression min, UniqueExpression max);
    Value evaluate(genny::DefaultRandom& rng) const override;

private:
    const UniqueExpression _min;
    const UniqueExpression _max;
};


/**
 * Class for generating random int64_t values according to a binomial distribution.
 *
 * See std::binomial_distribution for more details.
 */
class BinomialIntExpression : public RandomIntExpression {
public:
    BinomialIntExpression(UniqueExpression t, double p);
    Value evaluate(genny::DefaultRandom& rng) const override;

private:
    const UniqueExpression _t;
    const double _p;
};


/**
 * Class for generating random int64_t values according to a negative binomial distribution.
 *
 * See std::negative_binomial_distribution for more details.
 */
class NegativeBinomialIntExpression : public RandomIntExpression {
public:
    NegativeBinomialIntExpression(UniqueExpression k, double p);
    Value evaluate(genny::DefaultRandom& rng) const override;

private:
    const UniqueExpression _k;
    const double _p;
};


/**
 * Class for generating random int64_t values according to a geometric distribution.
 *
 * See std::geometric_distribution for more details.
 */
class GeometricIntExpression : public RandomIntExpression {
public:
    GeometricIntExpression(double p);
    Value evaluate(genny::DefaultRandom& rng) const override;

private:
    const double _p;
};


/**
 * Class for generating random int64_t values according to a poisson distribution.
 *
 * See std::poisson_distribution for more details.
 */
class PoissonIntExpression : public RandomIntExpression {
public:
    PoissonIntExpression(double mean);
    Value evaluate(genny::DefaultRandom& rng) const override;

private:
    const double _mean;
};

/**
 * Class for generating random std::string values with a specified length and using an optionally
 * specified alphabet.
 */
class RandomStringExpression : public Expression {
public:
    static constexpr auto kDefaultAlphabet = std::string_view{
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz"
        "0123456789+/"};

    static UniqueExpression parse(YAML::Node node);

    RandomStringExpression(UniqueExpression length, std::optional<std::string> alphabet);
    Value evaluate(genny::DefaultRandom& rng) const override;

private:
    const UniqueExpression _length;
    const std::optional<std::string> _alphabet;
};

/**
 * Class for generating random std::string values with a specified length and a fixed alphabet.
 */
class FastRandomStringExpression : public Expression {
public:
    static constexpr auto kAlphabet = RandomStringExpression::kDefaultAlphabet;
    static constexpr auto kAlphabetLength = kAlphabet.size();

    static UniqueExpression parse(YAML::Node node);

    FastRandomStringExpression(UniqueExpression length);
    Value evaluate(genny::DefaultRandom& rng) const override;

private:
    const UniqueExpression _length;
};

}  // namespace genny::value_generators

#endif  // HEADER_E6E05F14_BE21_4A9B_822D_FFD669CFB1B4_INCLUDED
