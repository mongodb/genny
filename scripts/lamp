#!/usr/bin/env python3

"""
Because genies come from lamps.
"""

from __future__ import print_function

import argparse
import logging
import os
import platform
import shutil
import subprocess
import sys
import tarfile
import urllib.request


class Context:
    # Permanent constants.
    TOOLCHAIN_BUILD_ID = '7297534c3dc1df9f6d315098174171eaf75c5846_19_02_09_02_19_44'
    TOOLCHAIN_GIT_HASH = TOOLCHAIN_BUILD_ID.split('_')[0]

    # User configurable constants.
    IGNORE_TOOLCHAIN_VERSION = False


def get_toolchain_url(os_family, distro=None):
    # These build IDs are from the genny-toolchain Evergreen task.
    # https://evergreen.mongodb.com/waterfall/genny-toolchain
    if os_family == 'Darwin':
        distro = 'macos_1014'

    return 'https://s3.amazonaws.com/mciuploads/genny-toolchain/' \
           'genny_toolchain_{}_{}/gennytoolchain.tgz'.format(distro, Context.TOOLCHAIN_BUILD_ID)


def check_toolchain_githash(toolchain_dir):
    res = subprocess.run(['git', 'rev-parse', 'HEAD'], cwd=toolchain_dir, capture_output=True, text=True)
    return res.stdout.strip() == Context.TOOLCHAIN_GIT_HASH


def fetch_and_install_toolchain(url, install_dir):
    if not os.path.exists(install_dir):
        logging.critical(
            'Please create the parent directory for gennytoolchain: '
            '`sudo mkdir -p %s; sudo chown $USER %s`', install_dir, install_dir)
        sys.exit(1)

    if not os.access(install_dir, os.W_OK):
        logging.critical(
            'Please ensure you have write access to the parent directory for gennytoolchain: '
            '`sudo chown $USER %s`', install_dir)
        sys.exit(1)

    toolchain_dir = os.path.join(install_dir, 'gennytoolchain')
    # If the toolchain dir is outdated or we ignore the toolchain version.
    if os.path.exists(toolchain_dir) and (
            Context.IGNORE_TOOLCHAIN_VERSION or check_toolchain_githash(toolchain_dir)):
        logging.info('Skipping installing the toolchain into: %s', toolchain_dir)
    else:
        toolchain_tarball = os.path.join(install_dir, 'gennytoolchain.tgz')
        if os.path.isfile(toolchain_tarball):
            logging.info('Skipping downloading %s', toolchain_tarball)
        else:
            logging.info('Downloading gennytoolchain (>1GB), please wait...')
            urllib.request.urlretrieve(url, toolchain_tarball)
            logging.info('Finished Downloading gennytoolchain as %s', toolchain_tarball)

        logging.info('Extracting gennytoolchain into %s, please wait...', toolchain_dir)
        tarball = tarfile.open(toolchain_tarball)

        shutil.rmtree(toolchain_dir, ignore_errors=True)
        tarball.extractall(toolchain_dir)
        logging.info('Finished extracting gennytoolchain into %s', toolchain_dir)

        # Get 1GB back.
        os.remove(toolchain_tarball)

    return toolchain_dir


def _create_compile_environment(toolchain_dir, triplet_os):
    env = os.environ.copy()
    paths = [env['PATH']]

    # For mongodbtoolchain compiler (if there).
    paths.insert(0, '/opt/mongodbtoolchain/v3/bin')

    # For cmake and ctest
    cmake_bin_relative_dir = {
        'linux': 'downloads/tools/cmake-3.13.3-linux/cmake-3.13.3-Linux-x86_64/bin',
        'osx': 'downloads/tools/cmake-3.13.3-osx/cmake-3.13.3-Darwin-x86_64/CMake.app/Contents/bin'
    }[triplet_os]
    paths.insert(0, os.path.join(toolchain_dir, cmake_bin_relative_dir))

    # For ninja
    ninja_bin_dir = os.path.join(toolchain_dir,
                                 'downloads/tools/ninja-1.8.2-{}:'.format(triplet_os))
    paths.insert(0, ninja_bin_dir)

    env['PATH'] = ':'.join(paths)
    env['NINJA_STATUS'] = '[%f/%t (%p) %es]'  # make the ninja output even nicer

    logging.debug('Using environment: %s', env)
    return env


def cmake(toolchain_dir, cmdline_args, cmdline_cmake_args, triplet_os, env):
    generators = {
        'make': 'Unix Makefiles',
        'ninja': 'Ninja'
    }
    cmake_cmd = ['cmake', '-B', 'build', '-G', generators[cmdline_args.build_system]]
    # We set both the prefix path and the toolchain file here as a hack to allow cmake
    # to find both shared and static libraries. vcpkg doesn't natively support a project
    # using both.
    cmake_prefix_path = os.path.join(toolchain_dir, 'installed/x64-{}-shared'.format(triplet_os))
    cmake_toolchain_file = os.path.join(toolchain_dir, 'scripts/buildsystems/vcpkg.cmake')

    cmake_cmd += [
        '-DCMAKE_PREFIX_PATH={}'.format(cmake_prefix_path),
        '-DCMAKE_TOOLCHAIN_FILE={}'.format(cmake_toolchain_file),
        '-DVCPKG_TARGET_TRIPLET=x64-{}-static'.format(triplet_os),
    ]

    cmake_cmd += cmdline_cmake_args

    logging.info('Running cmake: %s', ' '.join(cmake_cmd))
    subprocess.run(cmake_cmd, env=env)


def compile(env, args):
    compile_cmd = [args.build_system, '-C', 'build']
    logging.info('Compiling: %s', ' '.join(compile_cmd))
    subprocess.run(compile_cmd, env=env)


def install(env, args):
    install_cmd = [args.build_system, '-C', 'build', 'install']
    logging.info('Running install: %s', ' '.join(install_cmd))
    subprocess.run(install_cmd, env=env)


def cmake_test(env, args):
    workdir = os.path.join(os.getcwd(), 'build')
    ctest_cmd = [
        'ctest',
        '--label-exclude',
        '(standalone|sharded|single_node_replset|three_node_replset)'
    ]
    subprocess.run(ctest_cmd, cwd=workdir, env=env)


def parse_args(args, os_family):
    parser = argparse.ArgumentParser(
        description='Script for building genny',
        epilog='Unknown positional arguments will be forwarded verbatim to the cmake invocation'
    )

    # Python can't natively check the distros of our supported platforms.
    # See https://bugs.python.org/issue18872 for more info.
    parser.add_argument('-d', '--linux-distro',
                        choices=['ubuntu1804', 'archlinux', 'rhel70', 'amazon2', 'not-linux'],
                        help='specify the linux distro you\'re on; if your system isn\'t available,'
                             ' please contact us at #workload-generation')
    parser.add_argument('-v', '--verbose', action='store_true')
    parser.add_argument('-i', '--ignore-toolchain-version', action='store_true',
                        help='ignore the toolchain version, allow use of a custom toolchain version')
    parser.add_argument('-b', '--build-system',
                        choices=['make', 'ninja'], default='ninja',
                        help='Which build-system to use for compilation. May need to use make for IDEs.')
    subparsers = parser.add_subparsers(
        dest='subcommand',
        description='subcommands perform specific actions; make sure you run this script without any '
                    'subcommand first to initialize the environment')
    subparsers.add_parser(
        'cmake-test', help='run cmake unit tests that don\'t connect to a MongoDB cluster')
    subparsers.add_parser('compile', help='just run the compile step for genny')
    subparsers.add_parser('install', help='just run the install step for genny')

    known_args, unknown_args = parser.parse_known_args(args)

    if os_family == 'Linux' and not known_args.subcommand and not known_args.linux_distro:
        raise ValueError('--linux-distro must be specified on Linux')

    return known_args, unknown_args


def add_args_to_context(args):
    logging.basicConfig(level=logging.DEBUG if args.verbose else logging.INFO)
    Context.IGNORE_TOOLCHAIN_VERSION = args.ignore_toolchain_version


def main():
    os_family = platform.system()
    args, cmake_args = parse_args(sys.argv[1:], os_family)
    add_args_to_context(args)

    # This code is temporary. BUILD-7624 will move things over to /opt/.
    toolchain_parent = {
        'Linux': '/data/mci',
        'Darwin': '/data/mci'
    }

    # Map of platform.system() to vcpkg's OS names.
    triplet_os = {
        'Darwin': 'osx',
        'Linux': 'linux',
        'NT': 'windows'
    }[os_family]

    url = get_toolchain_url(os_family, args.linux_distro)
    toolchain_dir = fetch_and_install_toolchain(url, toolchain_parent[os_family])
    env = _create_compile_environment(toolchain_dir, triplet_os=triplet_os)

    if not args.subcommand:
        logging.info('No subcommand specified; running cmake, compile and install')
        cmake(toolchain_dir, cmdline_args=args, cmdline_cmake_args=cmake_args, triplet_os=triplet_os, env=env)
        compile(env, args)
        install(env, args)
    else:
        # Always compile genny regardless of the subcommand.
        compile(env, args)

    if args.subcommand == 'install':
        install(env, args)
    if args.subcommand == 'cmake-test':
        cmake_test(env, args)


if __name__ == '__main__':
    main()
